<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Get Signatures - Local-first, zero-knowledge digital signature platform">
    <title>Get Signatures</title>
    <!-- Trunk: Build WASM from Rust crate -->
    <link data-trunk rel="rust" href="../wasm/Cargo.toml" data-wasm-opt="z" data-wasm-opt-params="--enable-bulk-memory --enable-nontrapping-float-to-int --enable-sign-ext --enable-mutable-globals" />
    <!-- Trunk: Copy static JS files -->
    <link data-trunk rel="copy-file" href="ltv-timestamp.js" />
    <link data-trunk rel="copy-file" href="sign.js" />
    <link data-trunk rel="copy-file" href="signature-pad.js" />
    <link data-trunk rel="copy-file" href="guided-flow.js" />
    <link data-trunk rel="copy-file" href="sw.js" />
    <!-- Trunk: Copy additional HTML pages -->
    <link data-trunk rel="copy-file" href="sign.html" />
    <link data-trunk rel="copy-file" href="auth.html" />
    <link data-trunk rel="copy-file" href="verify.html" />
    <link data-trunk rel="copy-file" href="reset-password.html" />
    <link data-trunk rel="copy-file" href="admin.html" />
    <link data-trunk rel="copy-file" href="pricing.html" />
    <link data-trunk rel="copy-file" href="legal.html" />
    <link data-trunk rel="copy-file" href="profile.html" />
    <!-- Trunk: Copy CSS and TypeScript bundle (required by sign.html) -->
    <link data-trunk rel="copy-file" href="geriatric.css" />
    <link data-trunk rel="copy-dir" href="js" />
    <!-- PDF.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <!-- pdf-lib for embedding signature images into PDFs -->
    <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
    <script src="ltv-timestamp.js" defer></script>
    <!-- TypeScript bundle for auth and other features -->
    <script type="module" src="js/bundle.js"></script>
    <style>
        :root {
            --bg-primary: #f5f5f5;
            --bg-secondary: white;
            --bg-tertiary: #f9fafb;
            --text-primary: #111827;
            --text-secondary: #6b7280;
            --text-tertiary: #9ca3af;
            --border-primary: #e5e7eb;
            --border-secondary: #d1d5db;
            --header-bg: #1e40af;
            --header-text: white;
            --accent-primary: #1e40af;
            --accent-hover: #1e3a8a;
            --success: #10b981;
            --shadow-sm: rgba(0,0,0,0.1);
        }

        body.dark-mode {
            --bg-primary: #111827;
            --bg-secondary: #1f2937;
            --bg-tertiary: #374151;
            --text-primary: #f9fafb;
            --text-secondary: #d1d5db;
            --text-tertiary: #9ca3af;
            --border-primary: #374151;
            --border-secondary: #4b5563;
            --header-bg: #1e3a8a;
            --header-text: #f9fafb;
            --accent-primary: #3b82f6;
            --accent-hover: #2563eb;
            --success: #10b981;
            --shadow-sm: rgba(0,0,0,0.3);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        .header {
            background: var(--header-bg);
            color: var(--header-text);
            padding: 1rem 2rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
            box-shadow: 0 2px 4px var(--shadow-sm);
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        .header h1 {
            font-size: 1.5rem;
            font-weight: 600;
        }

        .header-actions {
            display: flex;
            gap: 0.5rem;
        }

        /* Stepper */
        .stepper {
            background: var(--bg-secondary);
            padding: 1.5rem 2rem;
            border-bottom: 1px solid var(--border-primary);
            display: flex;
            justify-content: center;
            gap: 0;
            transition: background-color 0.3s ease;
        }

        .step {
            display: flex;
            align-items: center;
            color: var(--text-tertiary);
        }

        .step-circle {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: var(--border-primary);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 0.875rem;
            margin-right: 0.5rem;
        }

        .step-label {
            font-size: 0.875rem;
            font-weight: 500;
        }

        .step.active .step-circle {
            background: var(--accent-primary);
            color: white;
        }

        .step.active .step-label {
            color: var(--accent-primary);
        }

        .step.completed .step-circle {
            background: var(--success);
            color: white;
        }

        .step.completed .step-label {
            color: var(--success);
        }

        .step-connector {
            width: 60px;
            height: 2px;
            background: var(--border-primary);
            margin: 0 1rem;
        }

        .step.completed + .step-connector,
        .step-connector.completed {
            background: #10b981;
        }

        /* Buttons */
        .btn {
            padding: 0.625rem 1.25rem;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.875rem;
            font-weight: 500;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
        }

        .btn-primary {
            background: #1e40af;
            color: white;
        }

        .btn-primary:hover {
            background: #1e3a8a;
        }

        .btn-secondary {
            background: var(--bg-secondary);
            color: var(--text-primary);
            border: 1px solid var(--border-primary);
        }

        .btn-secondary:hover {
            background: var(--bg-tertiary);
        }

        .btn-success {
            background: #10b981;
            color: white;
        }

        .btn-success:hover {
            background: #059669;
        }

        .btn-danger {
            background: #ef4444;
            color: white;
        }

        .btn-danger:hover {
            background: #dc2626;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn:focus-visible {
            outline: 2px solid #1e40af;
            outline-offset: 2px;
        }

        /* Skip Link for Accessibility */
        .skip-link {
            position: absolute;
            top: -40px;
            left: 0;
            background: #1e40af;
            color: white;
            padding: 8px 16px;
            z-index: 2000;
            text-decoration: none;
            font-weight: 500;
        }

        .skip-link:focus {
            top: 0;
        }

        /* Focus styles for interactive elements */
        input:focus-visible, select:focus-visible, button:focus-visible {
            outline: 2px solid #1e40af;
            outline-offset: 2px;
        }

        .step:focus-visible {
            outline: 2px solid #1e40af;
            outline-offset: 4px;
            border-radius: 4px;
        }

        .field-type:focus-visible {
            outline: 2px solid #1e40af;
            outline-offset: 2px;
            border-radius: 8px;
        }

        .recipient-item:focus-visible {
            outline: 2px solid #1e40af;
            outline-offset: 2px;
        }

        .btn-sm {
            padding: 0.375rem 0.75rem;
            font-size: 0.75rem;
        }

        /* Main Content */
        .main-content {
            padding: 2rem;
            max-width: 1400px;
            margin: 0 auto;
        }

        /* Full-width mode for step 3 (Fields) - use all available space */
        .main-content.full-width {
            max-width: none;
            padding: 1rem 2rem;
        }

        .step-content {
            display: none;
        }

        .step-content.active {
            display: block;
        }

        /* Step 1: Upload */
        .upload-area {
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: 3rem;
            text-align: center;
            box-shadow: var(--shadow-sm);
        }

        .drop-zone {
            border: 2px dashed var(--border-primary);
            border-radius: 8px;
            padding: 4rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .drop-zone:hover, .drop-zone.dragover {
            border-color: var(--accent-primary);
            background: var(--bg-tertiary);
        }

        .drop-zone-icon {
            font-size: 4rem;
            margin-bottom: 1rem;
        }

        .drop-zone-text {
            font-size: 1.125rem;
            color: var(--text-primary);
            margin-bottom: 0.5rem;
        }

        .drop-zone-subtext {
            color: var(--text-tertiary);
        }

        /* Step 2: Recipients */
        .recipients-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
        }

        .card {
            background: var(--bg-secondary);
            border-radius: 12px;
            box-shadow: var(--shadow-sm);
            overflow: hidden;
        }

        .card-header {
            padding: 1rem 1.5rem;
            border-bottom: 1px solid var(--border-primary);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .card-header h3 {
            font-size: 1rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        .card-body {
            padding: 1.5rem;
        }

        .form-group {
            margin-bottom: 1rem;
        }

        .form-group label {
            display: block;
            font-size: 0.875rem;
            font-weight: 500;
            color: var(--text-primary);
            margin-bottom: 0.375rem;
        }

        .form-group input, .form-group select {
            width: 100%;
            padding: 0.625rem;
            border: 1px solid var(--border-primary);
            border-radius: 6px;
            font-size: 0.875rem;
            background: var(--bg-secondary);
            color: var(--text-primary);
        }

        .form-group input:focus, .form-group select:focus {
            outline: none;
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 3px rgba(30, 64, 175, 0.1);
        }

        .recipient-list {
            list-style: none;
            position: relative;
            min-height: 50px;
        }

        .recipient-item {
            display: flex;
            align-items: center;
            padding: 0.75rem;
            border: 1px solid var(--border-primary);
            border-radius: 8px;
            margin-bottom: 0.5rem;
            background: var(--bg-tertiary);
            cursor: grab;
            user-select: none;
            transition: transform 0.15s ease, box-shadow 0.15s ease, opacity 0.15s ease;
        }

        .recipient-item:active {
            cursor: grabbing;
        }

        .recipient-item.dragging {
            position: relative;
            z-index: 1000;
            box-shadow: 0 8px 16px rgba(0,0,0,0.15);
            background: var(--bg-secondary);
            transform: scale(1.02);
            cursor: grabbing;
        }

        .recipient-item.drag-over-above {
            transform: translateY(4px);
        }

        .recipient-item.drag-over-below {
            transform: translateY(-4px);
        }

        .recipient-item.drag-ghost {
            opacity: 0.4;
        }

        .drag-placeholder {
            height: 56px;
            border: 2px dashed #1e40af;
            border-radius: 8px;
            margin-bottom: 0.5rem;
            background: rgba(30, 64, 175, 0.05);
            transition: all 0.15s ease;
        }

        .recipient-drag-handle {
            cursor: grab;
            padding: 0.25rem;
            margin-right: 0.5rem;
            color: #9ca3af;
            display: flex;
            align-items: center;
        }

        .recipient-drag-handle:hover {
            color: #6b7280;
        }

        .recipient-order {
            width: 28px;
            height: 28px;
            background: #1e40af;
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
            font-weight: 600;
            margin-right: 0.75rem;
            flex-shrink: 0;
        }

        .recipient-info {
            flex: 1;
        }

        .recipient-name {
            font-weight: 500;
            color: #374151;
            font-size: 0.875rem;
        }

        .recipient-email {
            color: #6b7280;
            font-size: 0.75rem;
        }

        .recipient-actions {
            display: flex;
            gap: 0.25rem;
        }

        .recipient-actions button {
            padding: 0.25rem;
            background: none;
            border: none;
            cursor: pointer;
            color: #6b7280;
            border-radius: 4px;
        }

        .recipient-actions button:hover {
            background: #e5e7eb;
            color: #374151;
        }

        /* PDF Preview in Recipients */
        .pdf-preview-small {
            max-height: 400px;
            overflow: auto;
            background: #e5e7eb;
            border-radius: 8px;
            padding: 1rem;
        }

        .pdf-preview-small canvas {
            /* Removed max-width: 100% - it blocks horizontal scroll when zoomed > 100% */
            height: auto;
            display: block;
            margin: 0 auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        /* Step 3: Fields */
        .fields-container {
            display: grid;
            grid-template-columns: 280px 1fr;
            gap: 1.5rem;
            min-height: 600px;
        }

        .field-toolbar {
            background: var(--bg-secondary);
            border-radius: 12px;
            box-shadow: var(--shadow-sm);
            overflow: hidden;
            display: flex;
            flex-direction: column;
            position: sticky;
            top: 1rem;
            max-height: calc(100vh - 200px);
        }

        .field-toolbar-header {
            padding: 1rem;
            border-bottom: 1px solid var(--border-primary);
        }

        .field-toolbar-header h3 {
            font-size: 0.875rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 0.5rem;
        }

        .recipient-selector {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid var(--border-primary);
            border-radius: 6px;
            font-size: 0.875rem;
            background: var(--bg-secondary);
            color: var(--text-primary);
        }

        .field-types {
            padding: 1rem;
            flex: 1;
            overflow: auto;
        }

        .field-type {
            display: flex;
            align-items: center;
            padding: 0.75rem;
            border: 2px solid var(--border-primary);
            border-radius: 8px;
            margin-bottom: 0.5rem;
            cursor: pointer;
            transition: all 0.2s;
            background: var(--bg-secondary);
        }

        .field-type:hover {
            border-color: var(--accent-primary);
            background: var(--bg-tertiary);
        }

        .field-type.selected {
            border-color: var(--accent-primary);
            background: var(--bg-tertiary);
            box-shadow: 0 0 0 2px rgba(30, 64, 175, 0.2);
        }

        .field-type-icon {
            width: 36px;
            height: 36px;
            background: var(--bg-tertiary);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 0.75rem;
            font-size: 1.25rem;
        }

        .field-type-label {
            font-weight: 500;
            color: var(--text-primary);
            font-size: 0.875rem;
        }

        .pdf-editor {
            background: var(--bg-secondary);
            border-radius: 12px;
            box-shadow: var(--shadow-sm);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .pdf-editor-header {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid var(--border-primary);
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-shrink: 0;
        }

        .page-nav {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .page-nav button {
            padding: 0.375rem 0.75rem;
            background: #f3f4f6;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            cursor: pointer;
        }

        .page-nav button:hover:not(:disabled) {
            background: #e5e7eb;
        }

        .page-nav span {
            font-size: 0.875rem;
            color: #374151;
        }

        .placement-hint {
            font-size: 0.75rem;
            color: #6b7280;
            padding: 0.375rem 0.75rem;
            background: #fef3c7;
            border-radius: 4px;
            display: none;
        }

        .placement-hint.active {
            display: block;
            color: #92400e;
        }

        .pdf-canvas-container {
            flex: 1;
            overflow: auto;
            background: #e5e7eb;
            padding: 1.5rem;
            min-height: 500px;
            max-height: calc(100vh - 280px);
        }

        .pdf-pages-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
        }

        /* On small screens, don't center - allows horizontal scroll without clipping left side */
        @media (max-width: 768px) {
            .pdf-pages-wrapper {
                align-items: flex-start;
            }
        }

        /* Mobile responsive styles */
        @media (max-width: 480px) {
            /* Ensure form inputs meet 44px minimum touch target (Apple HIG) */
            .form-group input, .form-group select {
                min-height: 44px;
                padding: 0.75rem;
                font-size: 1rem; /* Prevent iOS zoom on focus */
            }

            /* Stepper: make step labels smaller to fit */
            .step-label {
                font-size: 0.75rem;
            }

            .step-connector {
                width: 30px;
                margin: 0 0.5rem;
            }

            /* Recipients container: single column grid on mobile */
            .recipients-container {
                grid-template-columns: 1fr !important;
            }

            /* Smaller header padding */
            .header {
                padding: 0.75rem 1rem;
            }

            .header h1 {
                font-size: 1.25rem;
            }

            /* Button touch targets */
            .btn {
                min-height: 44px;
                padding: 0.75rem 1rem;
            }
        }

        .pdf-page-wrapper {
            position: relative;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            background: var(--bg-secondary);
        }

        .pdf-page-wrapper canvas {
            display: block;
        }

        .pdf-page-wrapper.placement-mode {
            cursor: crosshair;
        }

        /* Placed Fields */
        .placed-field {
            position: absolute;
            border: 2px solid;
            border-radius: 4px;
            cursor: move;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
            font-weight: 500;
            min-width: 80px;
            min-height: 24px;
            user-select: none;
        }

        .placed-field.selected {
            box-shadow: 0 0 0 2px rgba(30, 64, 175, 0.5);
        }

        .placed-field .delete-btn {
            position: absolute;
            top: -10px;
            right: -10px;
            width: 20px;
            height: 20px;
            background: #ef4444;
            color: white;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            font-size: 0.75rem;
            display: none;
            align-items: center;
            justify-content: center;
        }

        .placed-field:hover .delete-btn,
        .placed-field.selected .delete-btn {
            display: flex;
        }

        .placed-field .resize-handle {
            position: absolute;
            width: 10px;
            height: 10px;
            background: currentColor;
            border-radius: 2px;
            right: -5px;
            bottom: -5px;
            cursor: se-resize;
        }

        .placed-field .required-indicator {
            position: absolute;
            top: -8px;
            left: -8px;
            color: #ef4444;
            font-size: 16px;
            font-weight: bold;
            background: white;
            border-radius: 50%;
            width: 18px;
            height: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1;
        }

        .placed-field {
            border-color: var(--recipient-color, #1e40af);
            background: color-mix(in srgb, var(--recipient-color, #1e40af) 10%, transparent);
            color: var(--recipient-color, #1e40af);
        }

        /* Ghost field that follows cursor */
        .ghost-field {
            position: fixed;
            pointer-events: none;
            opacity: 0.7;
            z-index: 1000;
            border: 2px dashed #1e40af;
            background: rgba(30, 64, 175, 0.1);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
            font-weight: 500;
            color: #1e40af;
            padding: 0.25rem 0.5rem;
        }

        /* Step 4: Review */
        .review-container {
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: 2rem;
        }

        .review-pdf {
            background: var(--bg-secondary);
            border-radius: 12px;
            box-shadow: var(--shadow-sm);
            overflow: hidden;
        }

        .review-pdf-header {
            padding: 1rem 1.5rem;
            border-bottom: 1px solid var(--border-primary);
        }

        .review-pdf-header h3 {
            font-size: 1rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        .review-pdf-body {
            max-height: 500px;
            overflow: auto;
            padding: 1.5rem;
            background: var(--bg-tertiary);
        }

        .review-pdf-body canvas {
            /* Removed max-width: 100% - it blocks horizontal scroll when zoomed > 100% */
            display: block;
            margin: 0 auto 1rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .review-sidebar {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .summary-card {
            background: var(--bg-secondary);
            border-radius: 12px;
            box-shadow: var(--shadow-sm);
            padding: 1.5rem;
        }

        .summary-card h4 {
            font-size: 0.875rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 1rem;
        }

        .summary-item {
            display: flex;
            justify-content: space-between;
            padding: 0.5rem 0;
            border-bottom: 1px solid var(--border-primary);
            font-size: 0.875rem;
        }

        .summary-item:last-child {
            border-bottom: none;
        }

        .summary-label {
            color: var(--text-secondary);
        }

        .summary-value {
            color: var(--text-primary);
            font-weight: 500;
        }

        /* Footer Actions */
        .footer-actions {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: var(--bg-secondary);
            padding: 1rem 2rem;
            border-top: 1px solid var(--border-primary);
            display: flex;
            justify-content: space-between;
            z-index: 100;
        }

        .footer-left, .footer-right {
            display: flex;
            gap: 0.75rem;
        }

        /* Audit Log Panel */
        .audit-panel {
            background: var(--bg-secondary);
            border-radius: 12px;
            box-shadow: var(--shadow-sm);
        }

        .audit-entry {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid var(--border-primary);
            font-size: 0.8125rem;
        }

        .audit-entry:last-child {
            border-bottom: none;
        }

        .audit-event {
            font-weight: 500;
            color: var(--text-primary);
        }

        .audit-time {
            color: var(--text-tertiary);
            font-size: 0.75rem;
        }

        /* Toast */
        .toast {
            position: fixed;
            bottom: 5rem;
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-tertiary);
            color: var(--text-primary);
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            font-size: 0.875rem;
            z-index: 1001;
            animation: slideUp 0.3s ease;
        }

        @keyframes slideUp {
            from { opacity: 0; transform: translateX(-50%) translateY(10px); }
            to { opacity: 1; transform: translateX(-50%) translateY(0); }
        }

        /* Loading */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--bg-primary);
            opacity: 0.95;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .loading-overlay.hidden {
            display: none;
        }

        .loading-overlay {
            flex-direction: column;
            gap: 20px;
        }

        .signing-progress {
            text-align: center;
            width: 300px;
        }

        .signing-progress .progress-text {
            margin-bottom: 10px;
            color: var(--text-secondary);
            font-size: 14px;
        }

        .signing-progress .progress-bar {
            height: 8px;
            background: #e2e8f0;
            border-radius: 4px;
            overflow: hidden;
        }

        .signing-progress .progress-fill {
            height: 100%;
            background: #4f46e5;
            border-radius: 4px;
            transition: width 0.3s ease;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid #e5e7eb;
            border-top-color: #1e40af;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden { display: none !important; }

        /* Modern button loading states (2026 UX best practices) */
        .btn-loading {
            position: relative;
            pointer-events: none;
            opacity: 0.85;
        }

        .btn-loading .btn-spinner {
            display: inline-block;
            width: 18px;
            height: 18px;
            border: 2px solid currentColor;
            border-right-color: transparent;
            border-radius: 50%;
            animation: btn-spin 0.75s linear infinite;
            margin-right: 8px;
            vertical-align: middle;
        }

        .btn-success-state {
            background-color: #10b981 !important;
            border-color: #059669 !important;
        }

        .btn-success-state .btn-spinner {
            animation: none;
            border: none;
            width: auto;
            height: auto;
        }

        .btn-success-state .btn-spinner::after {
            content: '\2713';
            font-size: 16px;
            font-weight: bold;
        }

        @keyframes btn-spin {
            to { transform: rotate(360deg); }
        }

        /* Screen reader only - visually hidden but accessible */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        /* Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1100;
        }

        .modal {
            background: var(--bg-secondary);
            border-radius: 12px;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1);
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .modal-header {
            padding: 1rem 1.5rem;
            border-bottom: 1px solid var(--border-primary);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-header h3 {
            font-size: 1.125rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 1.5rem;
            color: var(--text-tertiary);
            cursor: pointer;
            padding: 0.25rem;
            line-height: 1;
        }

        .modal-close:hover {
            color: var(--text-primary);
        }

        .modal-body {
            padding: 1.5rem;
            overflow-y: auto;
            flex: 1;
        }

        .modal-footer {
            padding: 1rem 1.5rem;
            border-top: 1px solid var(--border-primary);
            display: flex;
            justify-content: flex-end;
            gap: 0.75rem;
        }

        /* Template List Styles */
        .template-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .template-item {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem;
            border: 1px solid var(--border-primary);
            border-radius: 8px;
            margin-bottom: 0.5rem;
        }

        .template-item:hover {
            background: var(--bg-tertiary);
        }

        .template-info {
            flex: 1;
            min-width: 150px;
        }

        .template-name {
            font-weight: 500;
            color: var(--text-primary);
        }

        .template-meta {
            font-size: 0.75rem;
            color: #9ca3af;
            margin-top: 0.25rem;
        }

        .template-actions {
            display: flex;
            gap: 0.5rem;
        }

        .template-actions .btn-load {
            padding: 0.375rem 0.75rem;
            font-size: 0.75rem;
            background: #1e40af;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        .template-actions .btn-load:hover {
            background: #1e3a8a;
        }

        .template-actions .btn-delete {
            padding: 0.375rem 0.75rem;
            font-size: 0.75rem;
            background: white;
            color: #ef4444;
            border: 1px solid #ef4444;
            border-radius: 4px;
            cursor: pointer;
        }

        .template-actions .btn-delete:hover {
            background: #fef2f2;
        }

        .template-actions .btn-preview {
            padding: 0.375rem 0.75rem;
            font-size: 0.75rem;
            background: white;
            color: #6b7280;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            cursor: pointer;
        }

        .template-actions .btn-preview:hover {
            background: #f9fafb;
            border-color: #9ca3af;
        }

        .template-preview-content {
            width: 100%;
            margin-top: 0.75rem;
            padding-top: 0.75rem;
            border-top: 1px solid var(--border-primary);
        }

        .template-preview-content.hidden {
            display: none;
        }

        .template-preview-summary {
            font-size: 0.8rem;
            color: var(--text-secondary);
        }

        .template-preview-summary .preview-section {
            margin-bottom: 0.5rem;
        }

        .template-preview-summary .preview-section:last-child {
            margin-bottom: 0;
        }

        .field-type-badge {
            display: inline-block;
            background: var(--bg-tertiary);
            padding: 0.125rem 0.5rem;
            border-radius: 4px;
            margin-right: 0.25rem;
            font-size: 0.7rem;
        }

        .preview-empty, .preview-error {
            color: #9ca3af;
            font-style: italic;
            padding: 0.5rem 0;
        }

        .preview-error {
            color: #ef4444;
        }

        .empty-state {
            text-align: center;
            color: #9ca3af;
            padding: 2rem;
        }

        /* Template buttons in toolbar */
        .template-buttons {
            padding: 1rem;
            border-top: 1px solid #e5e7eb;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .template-buttons .btn {
            width: 100%;
            justify-content: center;
        }

        /* Signing Link Styles */
        .signing-link-item {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            padding: 1rem;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            background: #f9fafb;
        }

        .signing-link-item .recipient-info {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .signing-link-item .recipient-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }

        .signing-link-item .recipient-name {
            font-weight: 600;
            color: #374151;
        }

        .signing-link-item .recipient-email {
            font-size: 0.75rem;
            color: #6b7280;
        }

        .signing-link-item .link-container {
            display: flex;
            gap: 0.5rem;
            align-items: stretch;
        }

        .signing-link-item .link-input {
            flex: 1;
            padding: 0.5rem;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            font-size: 0.75rem;
            font-family: monospace;
            background: white;
            word-break: break-all;
        }

        .signing-link-item .btn-copy {
            padding: 0.5rem 0.75rem;
            background: #1e40af;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.75rem;
            white-space: nowrap;
        }

        .signing-link-item .btn-copy:hover {
            background: #1e3a8a;
        }

        .signing-link-item .btn-copy.copied {
            background: #10b981;
        }

        /* Certificate Indicator */
        .cert-indicator {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            margin-left: 1rem;
            padding: 0.25rem 0.5rem;
            background: rgba(16, 185, 129, 0.2);
            border-radius: 4px;
            font-size: 1rem;
            cursor: help;
        }

        .cert-indicator.hidden {
            display: none;
        }

        /* Certificate Info Display */
        .cert-info {
            background: #f3f4f6;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            padding: 1rem;
            margin-top: 1rem;
        }

        .cert-info-row {
            display: flex;
            justify-content: space-between;
            padding: 0.5rem 0;
            border-bottom: 1px solid #e5e7eb;
        }

        .cert-info-row:last-child {
            border-bottom: none;
        }

        .cert-info-label {
            font-weight: 600;
            color: #374151;
            font-size: 0.875rem;
        }

        .cert-info-value {
            color: #6b7280;
            font-size: 0.875rem;
            text-align: right;
            word-break: break-word;
            max-width: 60%;
        }

        .cert-valid {
            color: #10b981;
            font-weight: 600;
        }

        .cert-invalid {
            color: #ef4444;
            font-weight: 600;
        }

        /* Settings Modal Sections */
        .settings-section {
            margin-bottom: 1.5rem;
            padding-bottom: 1.5rem;
            border-bottom: 1px solid #e5e7eb;
        }

        .settings-section:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }

        .settings-section h4 {
            margin: 0 0 0.75rem 0;
            font-size: 1rem;
            color: #374151;
        }

        .file-input-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            margin-bottom: 0.75rem;
        }

        .file-input-group label {
            font-size: 0.875rem;
            color: #4b5563;
            font-weight: 500;
        }

        .file-input-group input[type="file"] {
            font-size: 0.875rem;
            padding: 0.5rem;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            background: white;
        }

        /* Landing Page - shown when not authenticated */
        .landing-page {
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
        }

        .landing-content {
            text-align: center;
            padding: 2rem;
            max-width: 600px;
        }

        .landing-title {
            font-size: 48px;
            color: white;
            margin-bottom: 1rem;
            font-weight: 700;
        }

        .landing-tagline {
            font-size: 24px;
            color: rgba(255, 255, 255, 0.8);
            margin-bottom: 3rem;
            line-height: 1.4;
        }

        .landing-buttons {
            display: flex;
            gap: 1.5rem;
            justify-content: center;
            flex-wrap: wrap;
        }

        .landing-btn {
            min-width: 200px;
            padding: 1rem 2rem;
            font-size: 20px;
            border-radius: 8px;
            font-weight: 600;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            min-height: 60px;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .landing-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .landing-btn.btn-primary {
            background: #1e40af;
            color: white;
            border: none;
        }

        .landing-btn.btn-secondary {
            background: transparent;
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.5);
        }

        .landing-btn.btn-secondary:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: white;
        }

        /* Responsive landing page */
        @media (max-width: 600px) {
            .landing-title {
                font-size: 36px;
            }
            .landing-tagline {
                font-size: 20px;
            }
            .landing-buttons {
                flex-direction: column;
                align-items: center;
            }
            .landing-btn {
                width: 100%;
                max-width: 300px;
            }
        }

        /* App container - hidden when not authenticated */
        #app-container.hidden {
            display: none !important;
        }

        /* Rotating tagline animation - fade with blur effect */
        .tagline-text {
            display: inline-block;
            transition: opacity 0.5s ease, filter 0.5s ease;
        }

        .tagline-text.fade-out {
            opacity: 0;
            filter: blur(4px);
        }

        .tagline-text.fade-in {
            opacity: 1;
            filter: blur(0);
        }

        /* Respect reduced motion preference */
        @media (prefers-reduced-motion: reduce) {
            .tagline-text {
                transition: none;
            }
            .tagline-text.fade-out,
            .tagline-text.fade-in {
                opacity: 1;
                filter: none;
            }
        }

        /* Bug #11: Floating Jump Navigation Buttons */
        .scroll-nav-buttons {
            position: absolute;
            bottom: 1rem;
            right: 1rem;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            z-index: 100;
            pointer-events: none; /* Container doesn't block clicks */
        }
        .scroll-nav-btn {
            width: 44px;
            height: 44px;
            border-radius: 50%;
            background: var(--surface, white);
            border: 1px solid var(--border, #e5e7eb);
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            cursor: pointer;
            font-size: 1.25rem;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: opacity 0.2s, transform 0.2s, background 0.2s;
            pointer-events: auto; /* Buttons are clickable */
        }
        .scroll-nav-btn:hover {
            transform: scale(1.1);
            background: var(--surface-hover, #f3f4f6);
        }
        .scroll-nav-btn:focus {
            outline: 2px solid var(--accent, #3b82f6);
            outline-offset: 2px;
        }
        .scroll-nav-btn.hidden {
            opacity: 0;
            pointer-events: none;
            transform: scale(0.8);
        }
        .scroll-nav-btn:active {
            transform: scale(0.95);
        }

        /* Bug #12: Editable Page Number Input */
        .page-indicator-wrapper {
            display: inline-flex;
            align-items: center;
            gap: 2px;
            min-width: 70px;
            text-align: center;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }
        .page-input-trigger {
            background: none;
            border: 1px solid transparent;
            border-radius: 4px;
            padding: 2px 6px;
            cursor: pointer;
            font: inherit;
            color: inherit;
            transition: background 0.2s, border-color 0.2s;
        }
        .page-input-trigger:hover {
            background: var(--surface-hover, rgba(255,255,255,0.1));
            border-color: var(--border, #e5e7eb);
        }
        .page-input-trigger:focus {
            outline: 2px solid var(--accent, #3b82f6);
            outline-offset: 2px;
        }
        .page-input {
            width: 50px;
            padding: 2px 4px;
            font: inherit;
            font-size: 0.875rem;
            text-align: center;
            border: 1px solid var(--accent, #3b82f6);
            border-radius: 4px;
            background: var(--surface, white);
            color: var(--text-primary);
        }
        .page-input:focus {
            outline: none;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.3);
        }
        .page-input.hidden, .page-input-trigger.hidden {
            display: none;
        }
    </style>
</head>
<body>
    <!-- Skip Link for keyboard users -->
    <a href="#main-content" class="skip-link">Skip to main content</a>

    <div id="loading-overlay" class="loading-overlay" role="alert" aria-live="polite" aria-label="Loading application">
        <div class="spinner" aria-hidden="true"></div>
        <p id="loading-message" style="color: var(--text-primary); font-size: 18px; margin-top: 16px;">Loading Get Signatures...</p>
    </div>

    <!-- Landing Page - shown when NOT authenticated -->
    <div id="landing-page" class="landing-page hidden">
        <div class="landing-content">
            <h1 class="landing-title">Get Signatures</h1>
            <p class="landing-tagline" aria-live="polite"><span class="tagline-text">Less friction. Faster signatures.</span></p>
            <div class="landing-buttons">
                <a href="auth.html" class="landing-btn btn-primary">Sign In</a>
                <a href="auth.html?tab=register" class="landing-btn btn-secondary">Create Account</a>
            </div>
        </div>
    </div>
    <script>
        // Rotating taglines - purely client-side, no server cost
        (function() {
            const taglines = [
                "Less friction. Faster signatures.",
                "Fewer steps. Faster signing.",
                "Get documents signed, faster",
                "Signing without unnecessary steps",
                "Faster signing from start to finish"
            ];

            let currentIndex = 0;

            function rotateTagline() {
                const taglineEl = document.querySelector('.tagline-text');
                if (!taglineEl) return;

                taglineEl.classList.add('fade-out');

                setTimeout(() => {
                    currentIndex = (currentIndex + 1) % taglines.length;
                    taglineEl.textContent = taglines[currentIndex];
                    taglineEl.classList.remove('fade-out');
                }, 500);
            }

            // Start rotation after page loads, rotate every 4 seconds
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', () => setInterval(rotateTagline, 4000));
            } else {
                setInterval(rotateTagline, 4000);
            }
        })();
    </script>

    <!-- App Container - shown when authenticated -->
    <div id="app-container" class="hidden">
        <!-- Ghost field for placement -->
        <div id="ghost-field" class="ghost-field hidden" aria-hidden="true"></div>

        <header class="header" role="banner">
        <h1>Get Signatures</h1>
        <div class="header-actions">
            <span id="doc-name" style="color: rgba(255,255,255,0.8); font-size: 0.875rem;"></span>
            <span id="cert-status-indicator" class="cert-indicator hidden" title="Certificate loaded" aria-label="Certificate is loaded">
                <span aria-hidden="true">ðŸ”’</span>
            </span>
            <!-- User info (shown when authenticated) -->
            <!-- Bug #4: Removed docs-remaining display - will be replaced with feedback system -->
            <div id="user-info" class="hidden" style="display: none; align-items: center; gap: 0.75rem; margin-left: 1rem; padding: 0.25rem 0.75rem; background: rgba(255,255,255,0.1); border-radius: 6px;">
                <span id="user-email" style="color: rgba(255,255,255,0.9); font-size: 0.875rem; max-width: 200px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;"></span>
                <!-- Feature 2: My Documents button -->
                <button id="btn-my-documents" class="btn" style="padding: 0.375rem 0.75rem; font-size: 0.75rem; background: rgba(255,255,255,0.2); border: 1px solid rgba(255,255,255,0.3); color: white;" onclick="toggleDashboard()">
                    My Documents
                </button>
                <a href="/profile.html" class="btn" style="padding: 0.375rem 0.75rem; font-size: 0.75rem; background: rgba(255,255,255,0.2); border: 1px solid rgba(255,255,255,0.3); color: white; text-decoration: none;">
                    Account
                </a>
                <button id="btn-logout" class="btn" style="padding: 0.375rem 0.75rem; font-size: 0.75rem; background: rgba(255,255,255,0.2); border: 1px solid rgba(255,255,255,0.3); color: white;">
                    Logout
                </button>
            </div>
            <button id="btn-dark-mode" class="btn btn-secondary" style="padding: 0.5rem 0.75rem; margin-left: 1rem;" title="Toggle dark mode" aria-label="Toggle dark mode">
                <span id="dark-mode-icon" aria-hidden="true">ðŸŒ™</span>
                <span class="sr-only">Toggle Dark Mode</span>
            </button>
            <script>
                // Initialize dark mode from localStorage on page load (before module loads)
                (function() {
                    const savedMode = localStorage.getItem('darkMode');
                    const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
                    if (savedMode === 'true' || (savedMode === null && prefersDark)) {
                        document.body.classList.add('dark-mode');
                        document.getElementById('dark-mode-icon').textContent = 'â˜€ï¸';
                    }
                })();
                // Settings modal functions
                function openSettingsModal() {
                    document.getElementById('settings-modal').classList.remove('hidden');
                }
                function closeSettingsModal() {
                    document.getElementById('settings-modal').classList.add('hidden');
                }
                window.openSettingsModal = openSettingsModal;
                window.closeSettingsModal = closeSettingsModal;
            </script>
            <button id="btn-settings" class="btn btn-secondary" style="padding: 0.5rem 0.75rem;" title="Settings" aria-label="Open settings" onclick="openSettingsModal()">
                <span aria-hidden="true">âš™ï¸</span>
                <span class="sr-only">Settings</span>
            </button>
            <!-- Bug #4: Feedback Button -->
            <button id="btn-feedback" class="btn btn-secondary" style="padding: 0.5rem 0.75rem;" title="Send Feedback" aria-label="Send feedback" onclick="openFeedbackModal()">
                <span aria-hidden="true">ðŸ’¬</span>
                <span class="sr-only">Feedback</span>
            </button>
        </div>
    </header>

    <!-- Stepper -->
    <nav class="stepper" role="navigation" aria-label="Document signing progress">
        <div class="step active" data-step="1" role="button" tabindex="0" aria-current="step" aria-label="Step 1: Upload, current step">
            <div class="step-circle" aria-hidden="true">1</div>
            <div class="step-label">Upload</div>
        </div>
        <div class="step-connector" aria-hidden="true"></div>
        <div class="step" data-step="2" role="button" tabindex="0" aria-label="Step 2: Recipients">
            <div class="step-circle" aria-hidden="true">2</div>
            <div class="step-label">Recipients</div>
        </div>
        <div class="step-connector" aria-hidden="true"></div>
        <div class="step" data-step="3" role="button" tabindex="0" aria-label="Step 3: Add Fields">
            <div class="step-circle" aria-hidden="true">3</div>
            <div class="step-label">Add Fields</div>
        </div>
        <div class="step-connector" aria-hidden="true"></div>
        <div class="step" data-step="4" role="button" tabindex="0" aria-label="Step 4: Review">
            <div class="step-circle" aria-hidden="true">4</div>
            <div class="step-label">Review</div>
        </div>
    </nav>

    <!-- Main Content -->
    <main id="main-content" class="main-content" role="main" style="padding-bottom: 80px;">
        <!-- Step 1: Upload -->
        <div id="step-1" class="step-content active" role="region" aria-labelledby="step1-heading">
            <h2 id="step1-heading" class="sr-only">Step 1: Upload Document</h2>
            <div class="upload-area">
                <div id="drop-zone" class="drop-zone" role="button" tabindex="0" aria-label="Upload PDF file. Click or drag and drop a PDF here.">
                    <div class="drop-zone-icon" aria-hidden="true">ðŸ“„</div>
                    <div class="drop-zone-text">Drag and drop your PDF here</div>
                    <div class="drop-zone-subtext">or click to browse files</div>
                    <input type="file" id="file-input" accept=".pdf" style="display: none;" aria-label="Select PDF file to upload">
                </div>
            </div>
        </div>

        <!-- Step 2: Recipients -->
        <div id="step-2" class="step-content" role="region" aria-labelledby="step2-heading">
            <h2 id="step2-heading" class="sr-only">Step 2: Add Recipients</h2>
            <div class="recipients-container">
                <div class="card">
                    <div class="card-header">
                        <h3 id="add-recipients-heading">Add Recipients</h3>
                    </div>

                    <!-- Add myself as recipient section -->
                    <div id="add-myself-section" class="card-body" style="border-bottom: 1px solid #e5e7eb; background: var(--bg-tertiary);">
                        <div style="display: flex; align-items: center; gap: 0.75rem;">
                            <input type="checkbox" id="add-myself-checkbox"
                                   style="width: 24px; height: 24px; cursor: pointer; accent-color: var(--accent-primary);">
                            <label for="add-myself-checkbox" style="cursor: pointer; font-size: 1rem; font-weight: 500;">
                                Add myself as a signer
                            </label>
                        </div>
                        <p style="margin-top: 0.5rem; font-size: 0.875rem; color: var(--text-secondary);">
                            You'll be added as the first signer using your account info
                        </p>
                    </div>

                    <div class="card-body" role="form" aria-labelledby="add-recipients-heading">
                        <p style="font-size: 0.875rem; color: var(--text-secondary); margin-bottom: 1rem;">
                            Add other people who need to sign or receive a copy:
                        </p>
                        <div class="form-group" style="display: flex; gap: 0.5rem;">
                            <div style="flex: 1;">
                                <label for="recipient-first-name">First Name</label>
                                <input type="text" id="recipient-first-name" placeholder="John" aria-required="true" autocomplete="given-name">
                            </div>
                            <div style="flex: 1;">
                                <label for="recipient-last-name">Last Name</label>
                                <input type="text" id="recipient-last-name" placeholder="Doe" aria-required="true" autocomplete="family-name">
                            </div>
                        </div>
                        <div class="form-group">
                            <label for="recipient-email">Email</label>
                            <input type="email" id="recipient-email" placeholder="john@example.com" aria-required="true" autocomplete="email">
                        </div>
                        <div class="form-group">
                            <label for="recipient-role">Role</label>
                            <select id="recipient-role" aria-describedby="role-description">
                                <option value="signer">Needs to Sign</option>
                                <option value="viewer">Receives a Copy</option>
                            </select>
                            <span id="role-description" class="sr-only">Select whether this recipient needs to sign or only receives a copy</span>
                        </div>
                        <button id="add-recipient-btn" class="btn btn-primary" style="width: 100%;">
                            Add Recipient
                        </button>
                    </div>

                    <div class="card-header" style="border-top: 1px solid #e5e7eb;">
                        <h3 id="signing-order-heading">Signing Order</h3>
                        <span style="font-size: 0.75rem; color: #6b7280;" aria-hidden="true">Drag to reorder</span>
                    </div>
                    <div class="card-body">
                        <ul id="recipient-list" class="recipient-list" role="list" aria-labelledby="signing-order-heading" aria-describedby="reorder-instructions">
                            <span id="reorder-instructions" class="sr-only">Recipients can be reordered by dragging. The signing order determines who signs first.</span>
                            <li style="text-align: center; color: #9ca3af; padding: 1rem;">
                                No recipients added yet
                            </li>
                        </ul>
                    </div>
                </div>

                <div class="card">
                    <div class="card-header">
                        <h3>Document Preview</h3>
                    </div>
                    <div class="card-body">
                        <!-- Preview Toolbar -->
                        <div id="preview-toolbar" style="display: flex; justify-content: space-between; align-items: center; padding: 0.5rem; background: var(--bg-tertiary); border-radius: 8px; margin-bottom: 0.5rem; flex-wrap: wrap; gap: 0.5rem;">
                            <!-- Zoom Controls -->
                            <div style="display: flex; align-items: center; gap: 0.25rem;">
                                <button id="preview-zoom-out" type="button" aria-label="Zoom out"
                                        style="width: 36px; height: 36px; border-radius: 6px; border: 1px solid var(--border-primary); background: var(--bg-secondary); cursor: pointer; font-size: 18px; display: flex; align-items: center; justify-content: center;">
                                    âˆ’
                                </button>
                                <span id="preview-zoom-level" style="min-width: 50px; text-align: center; font-size: 0.875rem; color: var(--text-secondary);">100%</span>
                                <button id="preview-zoom-in" type="button" aria-label="Zoom in"
                                        style="width: 36px; height: 36px; border-radius: 6px; border: 1px solid var(--border-primary); background: var(--bg-secondary); cursor: pointer; font-size: 18px; display: flex; align-items: center; justify-content: center;">
                                    +
                                </button>
                            </div>
                            <!-- Page Navigation -->
                            <div style="display: flex; align-items: center; gap: 0.25rem;">
                                <button id="preview-prev-page" type="button" aria-label="Previous page"
                                        style="width: 36px; height: 36px; border-radius: 6px; border: 1px solid var(--border-primary); background: var(--bg-secondary); cursor: pointer; font-size: 16px; display: flex; align-items: center; justify-content: center;">
                                    â—€
                                </button>
                                <span id="preview-page-indicator" style="min-width: 60px; text-align: center; font-size: 0.875rem; color: var(--text-secondary);">1 / 1</span>
                                <button id="preview-next-page" type="button" aria-label="Next page"
                                        style="width: 36px; height: 36px; border-radius: 6px; border: 1px solid var(--border-primary); background: var(--bg-secondary); cursor: pointer; font-size: 16px; display: flex; align-items: center; justify-content: center;">
                                    â–¶
                                </button>
                            </div>
                        </div>
                        <div id="preview-container" class="pdf-preview-small"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Step 3: Fields -->
        <div id="step-3" class="step-content" role="region" aria-labelledby="step3-heading">
            <h2 id="step3-heading" class="sr-only">Step 3: Place Signature Fields</h2>
            <div class="fields-container">
                <aside class="field-toolbar" role="complementary" aria-label="Field placement tools">
                    <div class="field-toolbar-header">
                        <h3 id="assign-fields-heading">Assign Fields To</h3>
                        <label for="current-recipient" class="sr-only">Select recipient for new fields</label>
                        <select id="current-recipient" class="recipient-selector" aria-labelledby="assign-fields-heading">
                            <!-- Populated dynamically -->
                        </select>
                    </div>
                    <div class="field-types" role="toolbar" aria-label="Field type selection">
                        <div class="field-type" data-type="pointer" role="button" tabindex="0" aria-pressed="false" aria-label="Select and move mode">
                            <div class="field-type-icon" aria-hidden="true">ðŸ–±ï¸</div>
                            <div class="field-type-label">Select / Move</div>
                        </div>
                        <div class="field-type" data-type="signature" role="button" tabindex="0" aria-pressed="false" aria-label="Place signature field">
                            <div class="field-type-icon" aria-hidden="true">âœï¸</div>
                            <div class="field-type-label">Signature</div>
                        </div>
                        <div class="field-type" data-type="initials" role="button" tabindex="0" aria-pressed="false" aria-label="Place initials field">
                            <div class="field-type-icon" aria-hidden="true">ðŸ”¤</div>
                            <div class="field-type-label">Initials</div>
                        </div>
                        <div class="field-type" data-type="date" role="button" tabindex="0" aria-pressed="false" aria-label="Place date signed field">
                            <div class="field-type-icon" aria-hidden="true">ðŸ“…</div>
                            <div class="field-type-label">Date Signed</div>
                        </div>
                        <div class="field-type" data-type="text" role="button" tabindex="0" aria-pressed="false" aria-label="Place text field">
                            <div class="field-type-icon" aria-hidden="true">ðŸ“</div>
                            <div class="field-type-label">Text Field</div>
                        </div>
                        <div class="field-type" data-type="checkbox" role="button" tabindex="0" aria-pressed="false" aria-label="Place checkbox field">
                            <div class="field-type-icon" aria-hidden="true">â˜‘ï¸</div>
                            <div class="field-type-label">Checkbox</div>
                        </div>
                    </div>
                    <div class="field-toolbar-header" style="display: none; border-top: 1px solid #e5e7eb; margin-top: 0.5rem;">
                        <h3 style="margin-bottom: 0.75rem;" id="field-options-heading">Field Options</h3>
                        <label for="field-required" style="display: flex; align-items: center; gap: 0.5rem; font-size: 0.875rem; cursor: pointer;">
                            <input type="checkbox" id="field-required" checked style="width: auto; cursor: pointer;" aria-describedby="field-required-desc">
                            <span>Required Field</span>
                        </label>
                        <span id="field-required-desc" class="sr-only">Mark this field as required for the signer to fill</span>
                    </div>
                    <div class="template-buttons" style="display: none;">
                        <button id="btn-save-template" class="btn btn-secondary btn-sm" aria-label="Save current fields as a reusable template">
                            Save as Template
                        </button>
                        <button id="btn-load-template" class="btn btn-secondary btn-sm" aria-label="Load a saved field template">
                            Load Template
                        </button>
                    </div>
                </aside>

                <div class="pdf-editor" role="application" aria-label="PDF document editor">
                    <div class="pdf-editor-header" style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 0.5rem;">
                        <!-- Zoom Controls for Step 3 -->
                        <div style="display: flex; align-items: center; gap: 0.25rem;">
                            <button id="fields-zoom-out" type="button" aria-label="Zoom out"
                                style="width: 32px; height: 32px; border-radius: 6px; border: 1px solid var(--border-primary); background: var(--bg-secondary); color: var(--text-primary); cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 1.25rem;">âˆ’</button>
                            <span id="fields-zoom-level" style="min-width: 50px; text-align: center; font-size: 0.875rem; color: var(--text-secondary);">100%</span>
                            <button id="fields-zoom-in" type="button" aria-label="Zoom in"
                                style="width: 32px; height: 32px; border-radius: 6px; border: 1px solid var(--border-primary); background: var(--bg-secondary); color: var(--text-primary); cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 1.25rem;">+</button>
                        </div>
                        <div class="page-nav" role="navigation" aria-label="Page navigation">
                            <button id="prev-page" aria-label="Go to previous page">â† Prev</button>
                            <span aria-live="polite">Page <span id="current-page">1</span> of <span id="total-pages">1</span></span>
                            <button id="next-page" aria-label="Go to next page">Next â†’</button>
                        </div>
                        <div id="placement-hint" class="placement-hint" role="status" aria-live="polite">
                            Click on document to place field. Press Esc to cancel.
                        </div>
                    </div>
                    <div id="pdf-canvas-container" class="pdf-canvas-container" role="img" aria-label="PDF document. Click to place signature fields.">
                        <div id="pdf-pages-wrapper" class="pdf-pages-wrapper">
                            <!-- PDF pages rendered here -->
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Step 4: Review -->
        <div id="step-4" class="step-content" role="region" aria-labelledby="step4-heading">
            <h2 id="step4-heading" class="sr-only">Step 4: Review and Sign</h2>
            <div class="review-container">
                <div class="review-pdf">
                    <div class="review-pdf-header">
                        <h3 id="doc-preview-heading">Document Preview</h3>
                    </div>
                    <!-- Review Preview Toolbar - consistent with Recipients page -->
                    <div id="review-toolbar" style="display: flex; justify-content: space-between; align-items: center; padding: 0.5rem 1.5rem; background: var(--bg-tertiary); border-bottom: 1px solid var(--border-primary); flex-wrap: wrap; gap: 0.5rem;">
                        <!-- Zoom Controls -->
                        <div style="display: flex; align-items: center; gap: 0.25rem;">
                            <button id="review-zoom-out" type="button" aria-label="Zoom out"
                                style="width: 32px; height: 32px; border-radius: 6px; border: 1px solid var(--border-primary); background: var(--bg-secondary); color: var(--text-primary); cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 1.25rem;">âˆ’</button>
                            <span id="review-zoom-level" style="min-width: 50px; text-align: center; font-size: 0.875rem; color: var(--text-secondary);">100%</span>
                            <button id="review-zoom-in" type="button" aria-label="Zoom in"
                                style="width: 32px; height: 32px; border-radius: 6px; border: 1px solid var(--border-primary); background: var(--bg-secondary); color: var(--text-primary); cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 1.25rem;">+</button>
                        </div>
                        <!-- Page Navigation -->
                        <div style="display: flex; align-items: center; gap: 0.25rem;">
                            <button id="review-prev-page" type="button" aria-label="Previous page"
                                style="width: 32px; height: 32px; border-radius: 6px; border: 1px solid var(--border-primary); background: var(--bg-secondary); color: var(--text-primary); cursor: pointer; display: flex; align-items: center; justify-content: center;">â—€</button>
                            <span id="review-page-indicator" style="min-width: 60px; text-align: center; font-size: 0.875rem; color: var(--text-secondary);">1 / 1</span>
                            <button id="review-next-page" type="button" aria-label="Next page"
                                style="width: 32px; height: 32px; border-radius: 6px; border: 1px solid var(--border-primary); background: var(--bg-secondary); color: var(--text-primary); cursor: pointer; display: flex; align-items: center; justify-content: center;">â–¶</button>
                        </div>
                    </div>
                    <div id="review-pdf-body" class="review-pdf-body" role="img" aria-labelledby="doc-preview-heading" aria-describedby="review-desc">
                        <span id="review-desc" class="sr-only">Preview of document with signature fields highlighted</span>
                        <!-- PDF pages rendered here -->
                    </div>
                </div>

                <div class="review-sidebar">
                    <div class="summary-card">
                        <h4>Document Summary</h4>
                        <div class="summary-item">
                            <span class="summary-label">Document</span>
                            <span id="summary-doc-name" class="summary-value">-</span>
                        </div>
                        <div class="summary-item">
                            <span class="summary-label">Pages</span>
                            <span id="summary-pages" class="summary-value">-</span>
                        </div>
                        <div class="summary-item">
                            <span class="summary-label">Recipients</span>
                            <span id="summary-recipients" class="summary-value">-</span>
                        </div>
                        <div class="summary-item">
                            <span class="summary-label">Fields</span>
                            <span id="summary-fields" class="summary-value">-</span>
                        </div>
                    </div>

                    <div class="summary-card" id="expiration-card">
                        <h4>Signing Deadline</h4>
                        <p style="font-size: 0.75rem; color: #6b7280; margin-bottom: 0.75rem;">
                            Set when the signing request expires
                        </p>
                        <div class="summary-item">
                            <label for="expiration-select" style="font-size: 0.875rem;">Expires in</label>
                            <select id="expiration-select" style="padding: 0.5rem; border: 1px solid #d1d5db; border-radius: 6px; font-size: 0.875rem;">
                                <option value="24">24 hours</option>
                                <option value="48">48 hours</option>
                                <option value="72">3 days</option>
                                <option value="168" selected>7 days</option>
                                <option value="336">14 days</option>
                                <option value="720">30 days</option>
                            </select>
                        </div>
                        <div id="expiration-info" class="hidden" style="margin-top: 0.5rem; padding: 0.5rem; background: #fef3c7; border-radius: 6px; font-size: 0.75rem; color: #92400e;">
                            <strong>Deadline:</strong> <span id="expiration-deadline">-</span>
                        </div>
                    </div>

                    <div class="summary-card">
                        <h4>Recipients</h4>
                        <div id="review-recipients">
                            <!-- Populated dynamically -->
                        </div>
                    </div>

                    <div class="summary-card" id="ltv-timestamp-card" style="display: none;">
                        <h4>Long-Term Validation (LTV)</h4>
                        <p style="font-size: 0.75rem; color: #6b7280; margin-bottom: 0.75rem;">
                            Add a trusted timestamp to ensure signature validity beyond certificate expiration
                        </p>
                        <button id="btn-add-timestamp" class="btn btn-primary" style="width: 100%; font-size: 0.875rem;">
                            Add Timestamp
                        </button>
                        <div id="timestamp-status" class="hidden" style="margin-top: 0.75rem; padding: 0.75rem; border-radius: 6px; font-size: 0.75rem;">
                            <!-- Status message -->
                        </div>
                    </div>

                    <section class="audit-panel" aria-labelledby="audit-heading">
                        <div class="card-header" style="display: flex; justify-content: space-between; align-items: center;">
                            <h3 id="audit-heading">Activity Log</h3>
                            <span id="audit-verification" style="font-size: 0.875rem;" role="status" aria-live="polite"></span>
                        </div>
                        <div id="audit-log" style="max-height: 200px; overflow: auto;" role="log" aria-label="Document activity log">
                            <!-- Populated dynamically -->
                        </div>
                    </section>
                </div>
            </div>
        </div>
    </main>

    <!-- Feature 2: Document Dashboard -->
    <section id="dashboard-section" class="hidden" style="padding: 2rem; max-width: 1200px; margin: 0 auto;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem;">
            <h2 style="font-size: 1.5rem; font-weight: 600; color: var(--text-primary);">My Documents</h2>
            <button class="btn btn-primary" onclick="toggleDashboard()">
                + New Document
            </button>
        </div>

        <!-- Sent/Inbox Tabs -->
        <div id="dashboard-tabs" style="display: flex; gap: 0; margin-bottom: 1.5rem; border-bottom: 2px solid var(--border-primary);">
            <button id="tab-sent" class="dashboard-tab active" onclick="switchDashboardTab('sent')" style="padding: 0.75rem 1.5rem; font-size: 0.875rem; font-weight: 600; background: none; border: none; cursor: pointer; border-bottom: 2px solid transparent; margin-bottom: -2px; color: var(--text-primary);">
                Sent <span id="sent-tab-count" style="font-weight: 400; color: var(--text-secondary);"></span>
            </button>
            <button id="tab-inbox" class="dashboard-tab" onclick="switchDashboardTab('inbox')" style="padding: 0.75rem 1.5rem; font-size: 0.875rem; font-weight: 600; background: none; border: none; cursor: pointer; border-bottom: 2px solid transparent; margin-bottom: -2px; color: var(--text-secondary);">
                Inbox <span id="inbox-tab-count" style="font-weight: 400; color: var(--text-secondary);"></span>
            </button>
        </div>

        <div id="dashboard-loading" style="text-align: center; padding: 3rem;">
            <div class="spinner" style="margin: 0 auto 1rem;"></div>
            <p style="color: var(--text-secondary);">Loading your documents...</p>
        </div>

        <div id="dashboard-error" class="hidden" style="padding: 1.5rem; background: #fef2f2; border: 1px solid #fecaca; border-radius: 8px; color: #991b1b; text-align: center;">
            <!-- Error message displayed here -->
        </div>

        <div id="dashboard-empty" class="hidden" style="text-align: center; padding: 3rem;">
            <div style="font-size: 3rem; margin-bottom: 1rem;">ðŸ“„</div>
            <h3 style="color: var(--text-primary); margin-bottom: 0.5rem;">No documents yet</h3>
            <p style="color: var(--text-secondary); margin-bottom: 1.5rem;">Start by creating your first document for signing.</p>
            <button class="btn btn-primary" onclick="toggleDashboard()">Create Document</button>
        </div>

        <!-- SENT Content -->
        <div id="dashboard-content-sent" class="hidden">
            <!-- Needs Action Section (declined docs - shown first with alert styling) -->
            <div id="dashboard-needs-action" class="hidden" style="margin-bottom: 2rem; background: #fef2f2; border: 1px solid #fecaca; border-radius: 12px; padding: 1rem;">
                <h3 style="font-size: 1.125rem; font-weight: 600; color: #dc2626; margin-bottom: 0.5rem; display: flex; align-items: center; gap: 0.5rem;">
                    <span style="font-size: 1.25rem;">!</span> Needs Action
                    <span id="needs-action-count" style="font-weight: 400; color: #7f1d1d; font-size: 0.875rem;"></span>
                </h3>
                <p style="font-size: 0.875rem; color: #7f1d1d; margin-bottom: 1rem;">
                    These documents were declined and need to be revised or discarded.
                </p>
                <div id="needs-action-list" style="display: flex; flex-direction: column; gap: 0.75rem;"></div>
            </div>

            <!-- In Progress Section -->
            <div id="dashboard-in-progress" class="hidden" style="margin-bottom: 2rem;">
                <h3 style="font-size: 1.125rem; font-weight: 600; color: var(--text-primary); margin-bottom: 1rem; padding-bottom: 0.5rem; border-bottom: 2px solid #f59e0b;">
                    <span style="color: #f59e0b;">â—</span> In Progress
                    <span id="in-progress-count" style="font-weight: 400; color: var(--text-secondary); font-size: 0.875rem;"></span>
                </h3>
                <div id="in-progress-list" style="display: flex; flex-direction: column; gap: 0.75rem;"></div>
            </div>

            <!-- Completed Section -->
            <div id="dashboard-completed" class="hidden" style="margin-bottom: 2rem;">
                <h3 style="font-size: 1.125rem; font-weight: 600; color: var(--text-primary); margin-bottom: 1rem; padding-bottom: 0.5rem; border-bottom: 2px solid #10b981;">
                    <span style="color: #10b981;">â—</span> Completed
                    <span id="completed-count" style="font-weight: 400; color: var(--text-secondary); font-size: 0.875rem;"></span>
                </h3>
                <div id="completed-list" style="display: flex; flex-direction: column; gap: 0.75rem;"></div>
            </div>

            <!-- Expired Section -->
            <div id="dashboard-expired" class="hidden" style="margin-bottom: 2rem;">
                <h3 style="font-size: 1.125rem; font-weight: 600; color: var(--text-primary); margin-bottom: 1rem; padding-bottom: 0.5rem; border-bottom: 2px solid #6b7280;">
                    <span style="color: #6b7280;">â—</span> Expired
                    <span id="expired-count" style="font-weight: 400; color: var(--text-secondary); font-size: 0.875rem;"></span>
                </h3>
                <div id="expired-list" style="display: flex; flex-direction: column; gap: 0.75rem;"></div>
            </div>

            <!-- Voided Section -->
            <div id="dashboard-voided" class="hidden" style="margin-bottom: 2rem;">
                <h3 style="font-size: 1.125rem; font-weight: 600; color: var(--text-primary); margin-bottom: 1rem; padding-bottom: 0.5rem; border-bottom: 2px solid #9ca3af;">
                    <span style="color: #9ca3af;">â—</span> Voided
                    <span id="voided-count" style="font-weight: 400; color: var(--text-secondary); font-size: 0.875rem;"></span>
                </h3>
                <div id="voided-list" style="display: flex; flex-direction: column; gap: 0.75rem;"></div>
            </div>
        </div>

        <!-- INBOX Content -->
        <div id="dashboard-content-inbox" class="hidden">
            <!-- To Sign Section -->
            <div id="dashboard-to-sign" class="hidden" style="margin-bottom: 2rem;">
                <h3 style="font-size: 1.125rem; font-weight: 600; color: var(--text-primary); margin-bottom: 1rem; padding-bottom: 0.5rem; border-bottom: 2px solid #3b82f6;">
                    <span style="color: #3b82f6;">â—</span> Awaiting Your Signature
                    <span id="to-sign-count" style="font-weight: 400; color: var(--text-secondary); font-size: 0.875rem;"></span>
                </h3>
                <div id="to-sign-list" style="display: flex; flex-direction: column; gap: 0.75rem;"></div>
            </div>

            <!-- Inbox Completed Section -->
            <div id="dashboard-inbox-completed" class="hidden" style="margin-bottom: 2rem;">
                <h3 style="font-size: 1.125rem; font-weight: 600; color: var(--text-primary); margin-bottom: 1rem; padding-bottom: 0.5rem; border-bottom: 2px solid #10b981;">
                    <span style="color: #10b981;">â—</span> You Signed
                    <span id="inbox-completed-count" style="font-weight: 400; color: var(--text-secondary); font-size: 0.875rem;"></span>
                </h3>
                <div id="inbox-completed-list" style="display: flex; flex-direction: column; gap: 0.75rem;"></div>
            </div>

            <!-- Inbox Declined Section -->
            <div id="dashboard-inbox-declined" class="hidden" style="margin-bottom: 2rem;">
                <h3 style="font-size: 1.125rem; font-weight: 600; color: var(--text-primary); margin-bottom: 1rem; padding-bottom: 0.5rem; border-bottom: 2px solid #ef4444;">
                    <span style="color: #ef4444;">â—</span> You Declined
                    <span id="inbox-declined-count" style="font-weight: 400; color: var(--text-secondary); font-size: 0.875rem;"></span>
                </h3>
                <div id="inbox-declined-list" style="display: flex; flex-direction: column; gap: 0.75rem;"></div>
            </div>
        </div>
    </section>

    <!-- Document Preview Modal -->
    <div id="doc-preview-modal" class="modal-overlay hidden" role="dialog" aria-modal="true" aria-labelledby="doc-preview-title">
        <div class="modal" style="max-width: 900px; width: 95vw; height: 90vh; display: flex; flex-direction: column;">
            <div style="display: flex; justify-content: space-between; align-items: center; padding: 1rem 1.5rem; border-bottom: 1px solid var(--border-primary);">
                <h3 id="doc-preview-title" style="font-size: 1.125rem; font-weight: 600; margin: 0;">Document Preview</h3>
                <button onclick="closeDocPreview()" style="background: none; border: none; font-size: 1.5rem; cursor: pointer; color: var(--text-secondary);">&times;</button>
            </div>
            <div id="doc-preview-content" style="flex: 1; overflow: auto; padding: 1rem; display: flex; justify-content: center; align-items: flex-start; background: var(--bg-tertiary);">
                <div id="doc-preview-loading" style="text-align: center; padding: 3rem;">
                    <div class="spinner" style="margin: 0 auto 1rem;"></div>
                    <p style="color: var(--text-secondary);">Loading document...</p>
                </div>
                <canvas id="doc-preview-canvas" style="max-width: 100%; box-shadow: 0 4px 12px rgba(0,0,0,0.15);"></canvas>
            </div>
            <div style="display: flex; justify-content: space-between; align-items: center; padding: 1rem 1.5rem; border-top: 1px solid var(--border-primary);">
                <div style="display: flex; align-items: center; gap: 1rem;">
                    <button id="doc-preview-prev" class="btn btn-secondary" onclick="previewPrevPage()" style="padding: 0.5rem 1rem;">â† Prev</button>
                    <span id="doc-preview-page-info" style="font-size: 0.875rem; color: var(--text-secondary);">Page 1 of 1</span>
                    <button id="doc-preview-next" class="btn btn-secondary" onclick="previewNextPage()" style="padding: 0.5rem 1rem;">Next â†’</button>
                </div>
                <button id="doc-preview-download" class="btn btn-primary" onclick="downloadPreviewDoc()">Download PDF</button>
            </div>
        </div>
    </div>

    <!-- Footer Actions -->
    <footer class="footer-actions" role="contentinfo">
        <div class="footer-left">
            <button id="btn-back" class="btn btn-secondary hidden" aria-label="Go back to previous step">
                â† Back
            </button>
        </div>
        <div class="footer-right">
            <!-- Save Draft disabled until server-side persistence is implemented -->
            <button id="btn-save-draft" class="btn btn-secondary" style="display: none;" aria-label="Save current progress as draft">
                Save Draft
            </button>
            <button id="btn-next" class="btn btn-primary hidden" aria-label="Continue to next step">
                Next â†’
            </button>
            <button id="btn-generate-links" class="btn btn-primary hidden" aria-label="Send document for signing">
                ðŸ“¤ Send for Signing
            </button>
            <button id="btn-send" class="btn btn-success hidden" aria-label="Sign the document">
                âœï¸ Sign Now
            </button>
            <button id="btn-download" class="btn btn-primary hidden" aria-label="Download the signed PDF document">
                Download Signed PDF
            </button>
        </div>
    </footer>

    <!-- Template Modals -->
    <div id="save-template-modal" class="modal-overlay hidden" role="dialog" aria-modal="true" aria-labelledby="save-template-title">
        <div class="modal">
            <div class="modal-header">
                <h3 id="save-template-title">Save Field Configuration as Template</h3>
                <button class="modal-close" onclick="closeSaveTemplateModal()" aria-label="Close dialog">&times;</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label for="template-name-input">Template Name</label>
                    <input type="text" id="template-name-input" placeholder="e.g., NDA Template, Contract Fields" style="width: 100%; padding: 0.625rem; border: 1px solid #d1d5db; border-radius: 6px; font-size: 0.875rem;" aria-required="true">
                </div>
                <p style="font-size: 0.875rem; color: #6b7280; margin-top: 1rem;">
                    This will save the current field positions and types as a reusable template.
                    Field positions are stored as percentages, so they work across different PDF sizes.
                </p>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeSaveTemplateModal()">Cancel</button>
                <button class="btn btn-primary" onclick="saveTemplate()">Save Template</button>
            </div>
        </div>
    </div>

    <div id="load-template-modal" class="modal-overlay hidden" role="dialog" aria-modal="true" aria-labelledby="load-template-title">
        <div class="modal">
            <div class="modal-header">
                <h3 id="load-template-title">Load Field Template</h3>
                <button class="modal-close" onclick="closeLoadTemplateModal()" aria-label="Close dialog">&times;</button>
            </div>
            <div class="modal-body">
                <ul id="template-list" class="template-list">
                    <!-- Populated dynamically -->
                </ul>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeLoadTemplateModal()">Close</button>
            </div>
        </div>
    </div>

    <!-- Signing Links Modal (Bug #15: Links hidden from sender - only delivered via email) -->
    <div id="signing-links-modal" class="modal-overlay hidden" role="dialog" aria-modal="true" aria-labelledby="signing-links-title">
        <div class="modal" style="max-width: 500px;">
            <div class="modal-header">
                <h3 id="signing-links-title">Ready to Send</h3>
                <button class="modal-close" onclick="closeSigningLinksModal()" aria-label="Close dialog">&times;</button>
            </div>
            <div class="modal-body">
                <p style="font-size: 0.875rem; color: #6b7280; margin-bottom: 1rem;">
                    Secure signing links will be sent to the following recipients via email:
                </p>

                <!-- Document Aliasing Fields (Feature 1) -->
                <div style="margin-bottom: 1rem; padding: 1rem; background: var(--bg-tertiary); border-radius: 8px; border: 1px solid var(--border-primary);">
                    <label for="document-alias" style="display: block; font-size: 0.75rem; font-weight: 600; color: var(--text-secondary); margin-bottom: 0.25rem;">
                        Document Name (optional)
                    </label>
                    <input type="text" id="document-alias"
                           placeholder="e.g., Q1 2026 Lease Agreement"
                           style="width: 100%; padding: 0.5rem; border: 1px solid var(--border-primary); border-radius: 6px; font-size: 0.875rem; margin-bottom: 0.75rem; background: var(--bg-secondary); color: var(--text-primary);">

                    <label for="signing-context" style="display: block; font-size: 0.75rem; font-weight: 600; color: var(--text-secondary); margin-bottom: 0.25rem;">
                        Context / Description (optional)
                    </label>
                    <input type="text" id="signing-context"
                           placeholder="e.g., Lease for 30 James Ave, Orlando FL"
                           style="width: 100%; padding: 0.5rem; border: 1px solid var(--border-primary); border-radius: 6px; font-size: 0.875rem; background: var(--bg-secondary); color: var(--text-primary);">

                    <p style="font-size: 0.7rem; color: var(--text-tertiary); margin-top: 0.5rem;">
                        These will appear in signing invitation emails to help recipients identify the document.
                    </p>
                </div>

                <div id="signing-links-rate-limit" class="hidden" style="padding: 1rem; background: #fef3c7; border-radius: 8px; color: #92400e; margin-bottom: 1rem; font-size: 0.875rem;">
                    <!-- Rate limit warning -->
                </div>
                <div id="signing-links-list" style="display: flex; flex-direction: column; gap: 0.75rem;">
                    <!-- Populated dynamically - shows recipients, NOT links -->
                </div>
                <div id="signing-links-error" class="hidden" style="padding: 1.25rem; background: #fffbeb; border: 1px solid #f59e0b; border-radius: 12px; color: #78350f; margin-top: 1rem; font-size: 0.95rem; line-height: 1.5;">
                    <!-- Error message - friendly amber styling instead of scary red -->
                </div>
                <div style="margin-top: 1.5rem; padding: 1rem; background: #f0fdf4; border-radius: 8px;">
                    <p style="font-size: 0.75rem; color: #166534; margin: 0;">
                        <strong>Security Note:</strong> Each recipient receives a unique encrypted link.
                        Links expire based on your deadline setting and can only be accessed by the intended recipient.
                    </p>
                </div>
            </div>
            <div class="modal-footer">
                <button id="btn-send-emails" class="btn btn-primary" onclick="sendSigningEmails()" aria-live="polite">
                    <span class="btn-spinner" style="display: none;"></span>
                    <span class="btn-text">Send Signing Requests</span>
                </button>
                <button class="btn btn-secondary" onclick="closeSigningLinksModal()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- TSA Configuration Modal -->
    <div id="tsa-config-modal" class="modal-overlay hidden" role="dialog" aria-modal="true" aria-labelledby="tsa-config-title">
        <div class="modal" style="max-width: 500px;">
            <div class="modal-header">
                <h3 id="tsa-config-title">Configure Timestamp Authority</h3>
                <button class="modal-close" onclick="closeTsaConfigModal()" aria-label="Close dialog">&times;</button>
            </div>
            <div class="modal-body">
                <div class="form-group" style="margin-bottom: 1rem;">
                    <label for="tsa-url-input" style="display: block; font-size: 0.875rem; font-weight: 500; margin-bottom: 0.5rem;">TSA Server URL</label>
                    <input type="url" id="tsa-url-input" placeholder="https://freetsa.org/tsr" style="width: 100%; padding: 0.625rem; border: 1px solid #d1d5db; border-radius: 6px; font-size: 0.875rem;" aria-required="true">
                </div>
                <div style="padding: 1rem; background: #fef3c7; border-radius: 8px; margin-bottom: 1rem;">
                    <p style="font-size: 0.75rem; color: #92400e; margin: 0;">
                        <strong>Note:</strong> Free TSA servers like freetsa.org may have CORS restrictions.
                        For production use, consider setting up your own TSA server or using a CORS proxy.
                    </p>
                </div>
                <div style="padding: 1rem; background: #eff6ff; border-radius: 8px;">
                    <p style="font-size: 0.75rem; color: #1e40af; margin: 0;">
                        <strong>What is LTV?</strong> Long-Term Validation adds a trusted timestamp to your signature,
                        ensuring it remains valid even after your certificate expires or is revoked.
                    </p>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeTsaConfigModal()">Cancel</button>
                <button class="btn btn-primary" onclick="confirmAddTimestamp()">Add Timestamp</button>
            </div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div id="settings-modal" class="modal-overlay hidden" role="dialog" aria-modal="true" aria-labelledby="settings-title">
        <div class="modal" style="max-width: 600px;">
            <div class="modal-header">
                <h3 id="settings-title">Settings</h3>
                <button class="modal-close" onclick="closeSettingsModal()" aria-label="Close dialog">&times;</button>
            </div>
            <div class="modal-body">
                <!-- Plan & Usage Section (Bug #6.3) -->
                <div id="plan-section" class="settings-section">
                    <h4>Plan & Usage</h4>
                    <div id="plan-info" style="background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 8px; padding: 1rem; margin-bottom: 0.75rem;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.75rem;">
                            <div style="display: flex; align-items: center; gap: 0.5rem;">
                                <span id="plan-tier-badge" style="background: #e6f0ff; color: #0056b3; padding: 0.25rem 0.75rem; border-radius: 20px; font-size: 0.875rem; font-weight: 600;">Free</span>
                                <span id="plan-billing-cycle" style="font-size: 0.75rem; color: #6b7280;"></span>
                            </div>
                            <a href="/pricing.html" style="font-size: 0.875rem; color: #0056b3; text-decoration: none;">Manage Plan</a>
                        </div>
                        <div style="margin-bottom: 0.5rem;">
                            <div style="display: flex; justify-content: space-between; font-size: 0.875rem; margin-bottom: 0.25rem;">
                                <span>Documents this month</span>
                                <span id="plan-usage-text" style="font-weight: 600;">0 / 3</span>
                            </div>
                            <div style="background: #e5e7eb; border-radius: 4px; height: 8px; overflow: hidden;">
                                <div id="plan-usage-bar" style="background: #0056b3; height: 100%; width: 0%; transition: width 0.3s ease;"></div>
                            </div>
                        </div>
                        <div id="plan-overage-info" style="display: none; font-size: 0.75rem; color: #b45309; margin-top: 0.5rem;">
                            <span id="plan-overage-text"></span>
                        </div>
                    </div>
                </div>

                <!-- Profile Section -->
                <div id="profile-section" class="settings-section">
                    <h4>Profile</h4>
                    <p style="font-size: 0.875rem; color: #6b7280; margin-bottom: 0.75rem;">
                        Update your name for signatures and personalized greetings.
                    </p>
                    <div style="display: flex; gap: 0.5rem; flex-wrap: wrap; margin-bottom: 0.75rem;">
                        <div style="flex: 2; min-width: 120px;">
                            <label for="profile-first-name" style="display: block; font-size: 0.875rem; font-weight: 500; margin-bottom: 0.25rem;">First Name</label>
                            <input type="text" id="profile-first-name" class="form-input" placeholder="First name" style="width: 100%; padding: 0.5rem; border: 1px solid #d1d5db; border-radius: 6px;">
                        </div>
                        <div style="flex: 1; min-width: 60px; max-width: 80px;">
                            <label for="profile-middle-initial" style="display: block; font-size: 0.875rem; font-weight: 500; margin-bottom: 0.25rem;">M.I.</label>
                            <input type="text" id="profile-middle-initial" class="form-input" placeholder="MI" maxlength="2" style="width: 100%; padding: 0.5rem; border: 1px solid #d1d5db; border-radius: 6px; text-transform: uppercase;">
                        </div>
                        <div style="flex: 2; min-width: 120px;">
                            <label for="profile-last-name" style="display: block; font-size: 0.875rem; font-weight: 500; margin-bottom: 0.25rem;">Last Name</label>
                            <input type="text" id="profile-last-name" class="form-input" placeholder="Last name" style="width: 100%; padding: 0.5rem; border: 1px solid #d1d5db; border-radius: 6px;">
                        </div>
                    </div>
                    <button id="btn-save-profile" class="btn btn-primary" onclick="saveProfile()" style="width: 100%;">
                        Save Profile
                    </button>
                    <div id="profile-status" style="margin-top: 0.5rem; font-size: 0.875rem; display: none;"></div>
                </div>

                <!-- Certificate Management Section -->
                <div class="settings-section">
                    <h4>Certificate Management</h4>
                    <p style="font-size: 0.875rem; color: #6b7280; margin-bottom: 0.75rem;">
                        Upload your certificate and private key for signing PDFs with PAdES.
                    </p>

                    <!-- File Inputs -->
                    <div class="file-input-group">
                        <label for="cert-file-input">Certificate File (.pem, .crt)</label>
                        <input type="file" id="cert-file-input" accept=".pem,.crt" aria-label="Select certificate file">
                    </div>
                    <div class="file-input-group">
                        <label for="key-file-input">Private Key File (.pem, .key)</label>
                        <input type="file" id="key-file-input" accept=".pem,.key" aria-label="Select private key file">
                    </div>
                    <button class="btn btn-primary" onclick="importCertificate()" style="margin-top: 0.5rem;">
                        Import Certificate
                    </button>

                    <!-- Current Certificate Info -->
                    <div id="cert-info-container" class="hidden">
                        <h5 style="margin: 1rem 0 0.5rem 0; font-size: 0.875rem; font-weight: 600;">Current Certificate</h5>
                        <div id="cert-info-display" class="cert-info">
                            <!-- Populated dynamically -->
                        </div>
                        <button class="btn btn-secondary" onclick="clearCertificate()" style="margin-top: 0.75rem; width: 100%;">
                            Clear Certificate
                        </button>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeSettingsModal()">Close</button>
            </div>
        </div>
    </div>

    <!-- Limit Reached Modal (Bug #6.3 - Soft Block) -->
    <div id="limit-modal" class="modal-overlay hidden" role="dialog" aria-modal="true" aria-labelledby="limit-title">
        <div class="modal" style="max-width: 480px;">
            <div class="modal-header" style="background: linear-gradient(135deg, #b45309 0%, #d97706 100%); color: white; border-radius: 12px 12px 0 0;">
                <h3 id="limit-title" style="display: flex; align-items: center; gap: 0.5rem;">
                    <span style="font-size: 1.5rem;">ðŸ“Š</span>
                    Monthly Limit Reached
                </h3>
                <button class="modal-close" onclick="closeLimitModal()" aria-label="Close dialog" style="color: white;">&times;</button>
            </div>
            <div class="modal-body" style="padding: 1.5rem;">
                <div style="text-align: center; margin-bottom: 1.5rem;">
                    <div style="font-size: 3rem; margin-bottom: 0.5rem;">ðŸ“„</div>
                    <p id="limit-message" style="font-size: 1rem; color: #334155; line-height: 1.6;">
                        You've used all 3 documents available on your Free plan this month.
                    </p>
                </div>

                <div style="background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 8px; padding: 1rem; margin-bottom: 1.5rem;">
                    <h4 style="font-size: 0.875rem; font-weight: 600; color: #475569; margin-bottom: 0.75rem;">
                        What you can still do:
                    </h4>
                    <ul style="margin: 0; padding-left: 1.25rem; color: #64748b; font-size: 0.875rem; line-height: 1.8;">
                        <li>View your existing documents</li>
                        <li>Download signed PDFs</li>
                        <li>Check document status</li>
                        <li>View your sending history</li>
                    </ul>
                </div>

                <p id="limit-reset-info" style="font-size: 0.875rem; color: #6b7280; text-align: center; margin-bottom: 1rem;">
                    Your limit resets on the 1st of next month.
                </p>

                <div style="display: flex; flex-direction: column; gap: 0.75rem;">
                    <a href="/pricing.html" class="btn btn-primary" style="text-align: center; text-decoration: none; padding: 0.875rem; font-size: 1rem;">
                        Upgrade Your Plan
                    </a>
                    <button class="btn btn-secondary" onclick="closeLimitModal()" style="padding: 0.875rem; font-size: 1rem;">
                        Continue Viewing
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Bug #4: Feedback Modal -->
    <div id="feedback-modal" class="modal-overlay hidden" role="dialog" aria-modal="true" aria-labelledby="feedback-title">
        <div class="modal" style="max-width: 500px;">
            <div class="modal-header" style="background: linear-gradient(135deg, #059669 0%, #10b981 100%); color: white; border-radius: 12px 12px 0 0;">
                <h3 id="feedback-title" style="display: flex; align-items: center; gap: 0.5rem;">
                    <span style="font-size: 1.5rem;">ðŸ’¬</span>
                    Send Feedback
                </h3>
                <button class="modal-close" onclick="closeFeedbackModal()" aria-label="Close dialog" style="color: white;">&times;</button>
            </div>
            <div class="modal-body" style="padding: 1.5rem;">
                <div class="form-group" style="margin-bottom: 1rem;">
                    <label for="feedback-type" style="display: block; font-weight: 600; margin-bottom: 0.5rem;">What type of feedback?</label>
                    <select id="feedback-type" style="width: 100%; padding: 0.75rem; border: 1px solid #d1d5db; border-radius: 8px; font-size: 16px;">
                        <option value="bug">Bug Report</option>
                        <option value="feature">Feature Request</option>
                        <option value="more_documents">Request More Documents</option>
                        <option value="feedback">General Feedback</option>
                    </select>
                </div>

                <div id="docs-request-section" class="form-group hidden" style="margin-bottom: 1rem;">
                    <label for="additional-docs" style="display: block; font-weight: 600; margin-bottom: 0.5rem;">How many additional documents do you need?</label>
                    <input type="number" id="additional-docs" min="1" max="100" value="10" style="width: 100%; padding: 0.75rem; border: 1px solid #d1d5db; border-radius: 8px; font-size: 16px;">
                </div>

                <div class="form-group" style="margin-bottom: 1rem;">
                    <label for="feedback-description" style="display: block; font-weight: 600; margin-bottom: 0.5rem;">Description</label>
                    <textarea id="feedback-description" rows="5" placeholder="Please describe your feedback, bug, or feature request..." style="width: 100%; padding: 0.75rem; border: 1px solid #d1d5db; border-radius: 8px; font-size: 16px; resize: vertical;"></textarea>
                    <p style="font-size: 12px; color: #6b7280; margin-top: 0.25rem;">Max 2000 characters</p>
                </div>

                <div id="feedback-status" class="hidden" style="padding: 0.75rem; border-radius: 8px; margin-bottom: 1rem;"></div>

                <div style="display: flex; gap: 0.75rem; justify-content: flex-end;">
                    <button class="btn btn-secondary" onclick="closeFeedbackModal()">Cancel</button>
                    <button id="btn-submit-feedback" class="btn btn-primary" onclick="submitFeedback()" style="background: #059669;">
                        Submit Feedback
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Consent Modal for Remote Signers -->
    <div id="consent-modal" class="modal-overlay hidden" role="dialog" aria-modal="true" aria-labelledby="consent-title">
        <div class="modal" style="max-width: 500px;">
            <div class="modal-header" style="background: linear-gradient(135deg, #1e40af 0%, #3b82f6 100%); color: white; border-radius: 12px 12px 0 0;">
                <h3 id="consent-title" style="display: flex; align-items: center; gap: 0.5rem;">
                    <span style="font-size: 1.5rem;">âœï¸</span>
                    Electronic Signature Consent
                </h3>
            </div>
            <div class="modal-body" style="padding: 1.5rem;">
                <div style="background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 8px; padding: 1rem; margin-bottom: 1rem;">
                    <p style="font-size: 1rem; line-height: 1.6; color: #334155; margin: 0;">
                        By clicking "I Agree & Sign", you consent to sign this document electronically.
                        Your electronic signature has the same legal effect as a handwritten signature.
                    </p>
                </div>

                <div style="margin-bottom: 1rem;">
                    <h4 style="font-size: 0.875rem; font-weight: 600; color: #475569; margin-bottom: 0.5rem;">
                        You are agreeing to:
                    </h4>
                    <ul style="margin: 0; padding-left: 1.25rem; color: #64748b; font-size: 0.875rem; line-height: 1.8;">
                        <li>Sign the document "<span id="consent-doc-name" style="font-weight: 500; color: #1e293b;">-</span>"</li>
                        <li>Your signature will be legally binding</li>
                        <li>A record of your signature will be kept</li>
                    </ul>
                </div>

                <div style="background: #fffbeb; border: 1px solid #fcd34d; border-radius: 8px; padding: 0.75rem; margin-bottom: 1rem;">
                    <p style="font-size: 0.8125rem; color: #92400e; margin: 0; display: flex; align-items: flex-start; gap: 0.5rem;">
                        <span style="font-size: 1rem;">âš ï¸</span>
                        <span>If you do not wish to sign electronically, please decline and contact the document sender.</span>
                    </p>
                </div>

                <label style="display: flex; align-items: flex-start; gap: 0.75rem; cursor: pointer; padding: 0.75rem; border: 1px solid #e2e8f0; border-radius: 8px; background: white;">
                    <input type="checkbox" id="consent-checkbox" style="width: 20px; height: 20px; margin-top: 2px; accent-color: #1e40af;">
                    <span style="font-size: 0.9375rem; color: #334155; line-height: 1.5;">
                        I have read and understand this consent form. I agree to sign this document electronically.
                    </span>
                </label>

                <!-- Privacy Notice Link (Bug #5) -->
                <p style="font-size: 0.75rem; color: #6b7280; margin-top: 1rem; text-align: center;">
                    By signing, you agree to our <a href="/legal.html#esign" target="_blank" style="color: #1e40af; text-decoration: underline;">E-Sign Disclosure</a> and <a href="/legal.html#privacy" target="_blank" style="color: #1e40af; text-decoration: underline;">Privacy Policy</a>.
                </p>
            </div>
            <div class="modal-footer" style="display: flex; gap: 0.75rem; justify-content: flex-end; padding: 1rem 1.5rem; background: #f8fafc; border-radius: 0 0 12px 12px;">
                <button class="btn btn-secondary" onclick="declineConsent()" style="min-width: 100px;">
                    Decline
                </button>
                <button id="consent-agree-btn" class="btn btn-primary" onclick="acceptConsent()" disabled style="min-width: 140px; background: #1e40af;">
                    âœï¸ I Agree & Sign
                </button>
            </div>
        </div>
    </div>

    <!-- Signature Capture Modal -->
    <div id="signature-capture-modal" class="modal-overlay hidden" role="dialog" aria-modal="true" aria-labelledby="sig-modal-title">
        <div class="modal" style="max-width: 500px; width: 95%;">
            <div class="modal-header" style="background: linear-gradient(135deg, #1e40af 0%, #3b82f6 100%); color: white; border-radius: 12px 12px 0 0; padding: 1rem 1.5rem;">
                <h3 id="sig-modal-title" style="display: flex; align-items: center; gap: 0.5rem; margin: 0; font-size: 1.25rem;">
                    <span style="font-size: 1.5rem;">âœï¸</span>
                    Add Your Signature
                </h3>
                <button onclick="closeSignatureModal()" style="background: none; border: none; color: white; cursor: pointer; font-size: 1.5rem; padding: 0; line-height: 1;" aria-label="Close">Ã—</button>
            </div>
            <div class="modal-body" style="padding: 0;">
                <!-- Tabs -->
                <div style="display: flex; border-bottom: 1px solid #e5e7eb;" role="tablist">
                    <button id="sig-tab-type" class="active" onclick="switchSignatureTab('type')" role="tab" aria-selected="true"
                        style="flex: 1; padding: 1rem; background: white; border: none; font-size: 1rem; font-weight: 500; cursor: pointer; border-bottom: 2px solid transparent; color: #6b7280; transition: all 0.2s;">
                        Type
                    </button>
                    <button id="sig-tab-draw" onclick="switchSignatureTab('draw')" role="tab" aria-selected="false"
                        style="flex: 1; padding: 1rem; background: white; border: none; font-size: 1rem; font-weight: 500; cursor: pointer; border-bottom: 2px solid transparent; color: #6b7280; transition: all 0.2s;">
                        Draw
                    </button>
                </div>

                <!-- Type Panel -->
                <div id="sig-type-panel" role="tabpanel" style="padding: 1.5rem;">
                    <div style="margin-bottom: 1rem;">
                        <label for="sig-typed-name" style="display: block; font-size: 0.875rem; font-weight: 500; color: #374151; margin-bottom: 0.5rem;">
                            Your Name
                        </label>
                        <input type="text" id="sig-typed-name" oninput="updateTypedSignaturePreview()" placeholder="Enter your name"
                            style="width: 100%; padding: 0.75rem; font-size: 1rem; border: 1px solid #d1d5db; border-radius: 8px; box-sizing: border-box;">
                    </div>
                    <div style="margin-bottom: 1rem;">
                        <label for="sig-font-select" style="display: block; font-size: 0.875rem; font-weight: 500; color: #374151; margin-bottom: 0.5rem;">
                            Font Style
                        </label>
                        <select id="sig-font-select" onchange="updateTypedSignaturePreview()"
                            style="width: 100%; padding: 0.75rem; font-size: 1rem; border: 1px solid #d1d5db; border-radius: 8px; background: white;">
                            <option value="Dancing Script">Dancing Script</option>
                            <option value="Great Vibes">Great Vibes</option>
                            <option value="Allura">Allura</option>
                            <option value="Pacifico">Pacifico</option>
                            <option value="Sacramento">Sacramento</option>
                        </select>
                    </div>
                    <div style="background: #f9fafb; border: 2px dashed #d1d5db; border-radius: 8px; padding: 1.5rem; text-align: center; min-height: 80px; display: flex; align-items: center; justify-content: center;">
                        <div id="sig-typed-preview" style="font-size: 36px; font-family: 'Dancing Script', cursive; color: #000; word-break: break-word;"></div>
                    </div>
                </div>

                <!-- Draw Panel -->
                <div id="sig-draw-panel" class="hidden" role="tabpanel" style="padding: 1.5rem;">
                    <p style="font-size: 0.875rem; color: #6b7280; margin: 0 0 1rem 0; text-align: center;">
                        Use your mouse or finger to draw your signature
                    </p>
                    <div style="background: #f9fafb; border: 2px dashed #d1d5db; border-radius: 8px; overflow: hidden; position: relative;">
                        <canvas id="sig-draw-canvas" style="width: 100%; height: 150px; display: block; cursor: crosshair; touch-action: none;"></canvas>
                        <div style="position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%); font-size: 0.75rem; color: #9ca3af; pointer-events: none;">
                            Sign above this line
                        </div>
                    </div>
                    <button onclick="clearSignaturePad()" style="margin-top: 0.75rem; padding: 0.5rem 1rem; background: #f3f4f6; border: 1px solid #d1d5db; border-radius: 6px; cursor: pointer; font-size: 0.875rem; color: #374151;">
                        Clear
                    </button>
                </div>
            </div>
            <div class="modal-footer" style="display: flex; gap: 0.75rem; justify-content: flex-end; padding: 1rem 1.5rem; background: #f8fafc; border-radius: 0 0 12px 12px; border-top: 1px solid #e5e7eb;">
                <button class="btn btn-secondary" onclick="closeSignatureModal()" style="min-width: 100px; padding: 0.75rem 1.5rem;">
                    Cancel
                </button>
                <button class="btn btn-primary" onclick="applySignature()" style="min-width: 140px; padding: 0.75rem 1.5rem; background: #1e40af;">
                    Apply Signature
                </button>
            </div>
        </div>
    </div>

    <!-- Google Fonts for cursive signatures -->
    <link href="https://fonts.googleapis.com/css2?family=Dancing+Script:wght@400;700&family=Great+Vibes&family=Allura&family=Pacifico&family=Sacramento&display=swap" rel="stylesheet">

    <style>
        /* Signature modal tab styles */
        #sig-tab-type.active, #sig-tab-draw.active {
            color: #1e40af !important;
            border-bottom-color: #1e40af !important;
        }
        #sig-tab-type:hover, #sig-tab-draw:hover {
            background: #f9fafb;
        }
    </style>

    </div><!-- End app-container -->

    <script type="module">
        // Wait for trunk's WASM module to complete initialization
        // Trunk exposes bindings on window.wasmBindings after init
        async function waitForWasm() {
            while (!window.wasmBindings) {
                await new Promise(r => setTimeout(r, 50));
            }
            return window.wasmBindings;
        }

        const wasm = await waitForWasm();
        const { DocSign, init_storage } = wasm;

        // Configure PDF.js
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        // Recipient colors
        const recipientColors = ['#1e40af', '#059669', '#d97706', '#7c3aed', '#db2777'];

        // Application State
        const state = {
            currentStep: 1,
            docSign: null,
            storage: null,
            pdfDoc: null,
            pdfBytes: null,
            fileName: '',
            recipients: [],
            placedFields: [],
            currentPage: 1,
            totalPages: 0,
            scale: 1.5,
            // Field placement state
            selectedFieldType: null, // 'signature', 'initials', etc. null means pointer mode
            // Page dimensions cache (for coordinate conversion during signing)
            pageDimensions: {}, // { pageNum: { width, height, canvasWidth, canvasHeight } }
            // Sequential signing state
            signingStatus: {
                currentSignerIndex: 0, // Index in signers array (0-based)
                completedSigners: []   // Array of recipient IDs who have signed
            },
            // Remote signing state
            remoteSession: {
                sessionId: null,
                encryptionKey: null, // CryptoKey for AES-GCM
                isRemoteSigner: false, // True when loaded from signing link
                recipientId: null, // Current recipient's ID when signing remotely
                expiresAt: null, // ISO date string for session expiration
                hasConsented: false // True after user accepts consent to sign
            }
        };

        // DOM Elements
        const elements = {
            loadingOverlay: document.getElementById('loading-overlay'),
            ghostField: document.getElementById('ghost-field'),
            steps: document.querySelectorAll('.step'),
            stepContents: document.querySelectorAll('.step-content'),
            stepConnectors: document.querySelectorAll('.step-connector'),
            dropZone: document.getElementById('drop-zone'),
            fileInput: document.getElementById('file-input'),
            docName: document.getElementById('doc-name'),
            recipientFirstName: document.getElementById('recipient-first-name'),
            recipientLastName: document.getElementById('recipient-last-name'),
            recipientEmail: document.getElementById('recipient-email'),
            recipientRole: document.getElementById('recipient-role'),
            addRecipientBtn: document.getElementById('add-recipient-btn'),
            recipientList: document.getElementById('recipient-list'),
            previewContainer: document.getElementById('preview-container'),
            currentRecipient: document.getElementById('current-recipient'),
            fieldTypes: document.querySelectorAll('.field-type'),
            fieldRequired: document.getElementById('field-required'),
            pdfPagesWrapper: document.getElementById('pdf-pages-wrapper'),
            pdfCanvasContainer: document.getElementById('pdf-canvas-container'),
            currentPageSpan: document.getElementById('current-page'),
            totalPagesSpan: document.getElementById('total-pages'),
            prevPageBtn: document.getElementById('prev-page'),
            nextPageBtn: document.getElementById('next-page'),
            placementHint: document.getElementById('placement-hint'),
            reviewPdfBody: document.getElementById('review-pdf-body'),
            summaryDocName: document.getElementById('summary-doc-name'),
            summaryPages: document.getElementById('summary-pages'),
            summaryRecipients: document.getElementById('summary-recipients'),
            summaryFields: document.getElementById('summary-fields'),
            reviewRecipients: document.getElementById('review-recipients'),
            auditLog: document.getElementById('audit-log'),
            auditVerification: document.getElementById('audit-verification'),
            btnBack: document.getElementById('btn-back'),
            btnNext: document.getElementById('btn-next'),
            btnSaveDraft: document.getElementById('btn-save-draft'),
            btnSend: document.getElementById('btn-send'),
            btnDownload: document.getElementById('btn-download'),
            btnGenerateLinks: document.getElementById('btn-generate-links'),
            btnSettings: document.getElementById('btn-settings'),
            btnDarkMode: document.getElementById('btn-dark-mode'),
            darkModeIcon: document.getElementById('dark-mode-icon'),
        };

        // Signing Worker Manager - handles async signing off main thread
        class SigningWorker {
            constructor() {
                this.worker = null;
                this.pendingCallbacks = new Map();
                this.nextId = 1;
                this.onProgress = null;
            }

            async init() {
                if (this.worker) return;

                return new Promise((resolve, reject) => {
                    this.worker = new Worker('signing-worker.js', { type: 'module' });

                    this.worker.onmessage = (e) => {
                        const { id, type, ...data } = e.data;

                        if (type === 'init') {
                            if (data.success) resolve();
                            else reject(new Error(data.error));
                            return;
                        }

                        if (type === 'progress' && this.onProgress) {
                            this.onProgress(data.stage, data.percent);
                            return;
                        }

                        if (type === 'loaded') {
                            const cb = this.pendingCallbacks.get('load');
                            if (cb) {
                                this.pendingCallbacks.delete('load');
                                if (data.success) cb.resolve();
                                else cb.reject(new Error(data.error));
                            }
                            return;
                        }

                        const callback = this.pendingCallbacks.get(id);
                        if (callback) {
                            this.pendingCallbacks.delete(id);
                            if (data.error) callback.reject(new Error(data.error));
                            else callback.resolve(data);
                        }
                    };

                    this.worker.onerror = (err) => {
                        reject(new Error(`Worker error: ${err.message}`));
                    };

                    // Send init message to worker
                    this.worker.postMessage({ action: 'init' });
                });
            }

            async loadPdf(pdfBytes) {
                return new Promise((resolve, reject) => {
                    this.pendingCallbacks.set('load', { resolve, reject });
                    this.worker.postMessage({
                        action: 'load',
                        data: { pdfBytes }
                    });
                });
            }

            async signField(page, x, y, width, height, reason, signerEmail) {
                const id = this.nextId++;
                return new Promise((resolve, reject) => {
                    this.pendingCallbacks.set(id, { resolve, reject });
                    this.worker.postMessage({
                        id,
                        action: 'sign',
                        data: { page, x, y, width, height, reason, signerEmail }
                    });
                });
            }

            async addTextField(page, x, y, width, height, value, fieldType) {
                const id = this.nextId++;
                return new Promise((resolve, reject) => {
                    this.pendingCallbacks.set(id, { resolve, reject });
                    this.worker.postMessage({
                        id,
                        action: 'addTextField',
                        data: { page, x, y, width, height, value, fieldType }
                    });
                });
            }

            async addCheckbox(page, x, y, size, checked) {
                const id = this.nextId++;
                return new Promise((resolve, reject) => {
                    this.pendingCallbacks.set(id, { resolve, reject });
                    this.worker.postMessage({
                        id,
                        action: 'addCheckbox',
                        data: { page, x, y, size, checked }
                    });
                });
            }

            async getPdf() {
                const id = this.nextId++;
                return new Promise((resolve, reject) => {
                    this.pendingCallbacks.set(id, { resolve, reject });
                    this.worker.postMessage({ id, action: 'getPdf' });
                });
            }

            terminate() {
                if (this.worker) {
                    this.worker.terminate();
                    this.worker = null;
                }
            }
        }

        // Global signing worker instance
        let signingWorker = null;

        // Initialize with timeout protection
        async function initialize() {
            const timeout = (promise, ms, name) => Promise.race([
                promise,
                new Promise((_, reject) => setTimeout(() => reject(new Error(`${name} timeout after ${ms}ms`)), ms))
            ]);

            try {
                // Note: WASM module is already initialized by Trunk's generated code
                // (see the <script type="module"> in <head> that calls init())
                console.log('WASM already initialized by Trunk, starting storage...');

                try {
                    state.storage = await timeout(init_storage(), 5000, 'Storage init');
                    console.log('Storage initialized');
                } catch (storageErr) {
                    console.warn('Storage init failed (non-fatal):', storageErr.message);
                    state.storage = null;
                }

                console.log('DocSigner initialized');

                // Initialize dark mode (already handled by inline script, but call for module state)
                // initDarkMode();

                // Check for signing link in URL first (recipients don't need auth)
                const hasSigningLink = window.location.hash.startsWith('#sign=');
                if (hasSigningLink) {
                    // Keep loading overlay while loading remote session
                    await checkForSigningLink();
                } else {
                    // Sender flow - requires authentication
                    const loadingMessage = document.getElementById('loading-message');
                    if (loadingMessage) {
                        loadingMessage.textContent = 'Checking authentication...';
                    }

                    // Wait for DocSign namespace to be available
                    let authCheckAttempts = 0;
                    while (!window.DocSign?.isAuthenticated && authCheckAttempts < 20) {
                        await new Promise(r => setTimeout(r, 100));
                        authCheckAttempts++;
                    }

                    // Check if authenticated
                    if (window.DocSign?.isAuthenticated && !window.DocSign.isAuthenticated()) {
                        // Not authenticated - show landing page
                        console.log('User not authenticated, showing landing page');
                        elements.loadingOverlay.classList.add('hidden');
                        const landingPage = document.getElementById('landing-page');
                        const appContainer = document.getElementById('app-container');
                        if (landingPage) {
                            landingPage.classList.remove('hidden');
                        }
                        if (appContainer) {
                            appContainer.classList.add('hidden');
                        }
                        return;
                    }

                    if (loadingMessage) {
                        loadingMessage.textContent = 'Loading application...';
                    }

                    // Show user info in header
                    if (window.DocSign?.getCurrentUser) {
                        const user = window.DocSign.getCurrentUser();
                        if (user) {
                            const userInfoEl = document.getElementById('user-info');
                            const userGreetingEl = document.getElementById('user-email');

                            // Bug #4: Removed docs-remaining display
                            if (userInfoEl && userGreetingEl) {
                                // Use first_name directly for friendly greeting
                                const firstName = user.first_name || 'there';
                                userGreetingEl.textContent = `Welcome back, ${firstName}`;
                                userInfoEl.classList.remove('hidden');
                                userInfoEl.style.display = 'flex';
                            }
                        }
                    }

                    // Setup logout button
                    const logoutBtn = document.getElementById('btn-logout');
                    if (logoutBtn) {
                        logoutBtn.addEventListener('click', async () => {
                            if (window.DocSign?.logout) {
                                await window.DocSign.logout();
                                window.location.href = 'auth.html';
                            }
                        });
                    }

                    // Check for incoming document from agentPDF
                    const incomingDoc = checkForAgentPdfDocument();
                    if (incomingDoc) {
                        console.log('Loading document from agentPDF:', incomingDoc.filename);
                        try {
                            await loadPdfFromBytes(incomingDoc.pdfBytes, incomingDoc.filename, incomingDoc.fields);
                            showToast('Document loaded from agentPDF', 'success');
                        } catch (loadErr) {
                            console.error('Failed to load agentPDF document:', loadErr);
                            showToast('Failed to load document: ' + loadErr.message);
                        }
                    }

                    // Show the app container
                    const appContainer = document.getElementById('app-container');
                    if (appContainer) {
                        appContainer.classList.remove('hidden');
                    }

                    elements.loadingOverlay.classList.add('hidden');
                    updateStepUI();
                    setupFieldPlacement();

                    // Check for saved drafts (only if no incoming document)
                    if (!incomingDoc) {
                        try {
                            await timeout(checkForDrafts(), 3000, 'Draft check');
                        } catch (draftErr) {
                            console.warn('Draft check failed (non-fatal):', draftErr.message);
                        }
                    }
                }
            } catch (err) {
                console.error('Failed to initialize:', err);
                elements.loadingOverlay.classList.add('hidden');
                showToast('Failed to initialize: ' + err.message);
            }
        }

        // Dark Mode
        function initDarkMode() {
            // Check localStorage first, then system preference
            const savedMode = localStorage.getItem('darkMode');
            const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;

            if (savedMode === 'true' || (savedMode === null && prefersDark)) {
                enableDarkMode();
            }
        }

        function toggleDarkMode() {
            if (document.body.classList.contains('dark-mode')) {
                disableDarkMode();
            } else {
                enableDarkMode();
            }
        }

        function enableDarkMode() {
            document.body.classList.add('dark-mode');
            elements.darkModeIcon.textContent = 'â˜€ï¸';
            localStorage.setItem('darkMode', 'true');
        }

        function disableDarkMode() {
            document.body.classList.remove('dark-mode');
            elements.darkModeIcon.textContent = 'ðŸŒ™';
            localStorage.setItem('darkMode', 'false');
        }

        // Expose dark mode toggle to window for onclick handler
        window.toggleDarkMode = toggleDarkMode;

        // Toast
        function showToast(message) {
            const toast = document.createElement('div');
            toast.className = 'toast';
            toast.textContent = message;
            document.body.appendChild(toast);
            setTimeout(() => toast.remove(), 3000);
        }

        // Audit trail stub - logs to console for now
        // TODO: Implement proper audit trail storage if needed
        function addAuditEntry(message) {
            console.log('[Audit]', new Date().toISOString(), message);
        }

        // Paul Graham style: direct, useful, no fluff
        function getPdfErrorMessage(technicalError) {
            const errorStr = String(technicalError || '').toLowerCase();

            if (errorStr.includes('invalid') || errorStr.includes('corrupt') || errorStr.includes('parse')) {
                return `PDF appears corrupted or in an unsupported format. Email bobamatchasolutions at gmail dot com with your PDF and we'll fix it.`;
            }
            if (errorStr.includes('password') || errorStr.includes('encrypted')) {
                return `PDF is password-protected. Remove the password and try again. Need help? Email bobamatchasolutions at gmail dot com.`;
            }
            if (errorStr.includes('storage') || errorStr.includes('indexeddb') || errorStr.includes('quota')) {
                return `Browser storage full. Clear some browser data or try a different browser. Email bobamatchasolutions at gmail dot com if stuck.`;
            }
            if (errorStr.includes('network') || errorStr.includes('fetch') || errorStr.includes('timeout')) {
                return `Network error. Check your connection and retry. Email bobamatchasolutions at gmail dot com if it persists.`;
            }

            return `PDF processing failed. Email bobamatchasolutions at gmail dot com with your PDF and we'll sort it out.`;
        }

        // Paul Graham style error for network/server issues
        // Bug #0: Enhanced error handling with specific error codes
        function getServerErrorMessage(technicalError) {
            const errorStr = String(technicalError || '').toLowerCase();

            // Check for specific error codes first (from enhanced API responses)
            if (errorStr.includes('body_parse_error')) {
                return `Invalid request format. Try refreshing the page and starting over. If this keeps happening, email bobamatchasolutions at gmail dot com.`;
            }
            if (errorStr.includes('auth_error')) {
                return `Authentication failed. Log out, log back in, and try again.`;
            }
            if (errorStr.includes('serialization_error') || errorStr.includes('kv_write_error') || errorStr.includes('kv_builder_error')) {
                return `Failed to save your session. This is a server issue - please try again in a minute. If it persists, email bobamatchasolutions at gmail dot com.`;
            }
            if (errorStr.includes('email_not_verified')) {
                return `Please verify your email address before creating signing sessions. Check your inbox for the verification email.`;
            }

            // Paul Graham style: direct, useful, no fluff
            if (errorStr.includes('network') || errorStr.includes('fetch') || errorStr.includes('failed to fetch')) {
                return `Can't reach our servers. Check your internet connection and try again. If the problem persists, email bobamatchasolutions at gmail dot com.`;
            }
            if (errorStr.includes('401') || errorStr.includes('403') || errorStr.includes('unauthorized')) {
                return `Session expired. Log out, log back in, and try again. If that doesn't work, email bobamatchasolutions at gmail dot com.`;
            }
            if (errorStr.includes('500') || errorStr.includes('server')) {
                return `Server error on our end. Wait a minute and retry. If it keeps failing, email bobamatchasolutions at gmail dot com.`;
            }
            if (errorStr.includes('rate') || errorStr.includes('limit') || errorStr.includes('quota')) {
                return `Daily limit reached. Try again tomorrow, or email bobamatchasolutions at gmail dot com for higher limits.`;
            }

            return `Something failed. Try again. If it keeps happening, email bobamatchasolutions at gmail dot com with what you were doing.`;
        }

        // Update signing progress - shows in loading overlay
        function updateSigningProgress(message, percent) {
            const overlay = elements.loadingOverlay;
            let progressEl = overlay.querySelector('.signing-progress');
            if (!progressEl) {
                progressEl = document.createElement('div');
                progressEl.className = 'signing-progress';
                progressEl.innerHTML = `
                    <div class="progress-text"></div>
                    <div class="progress-bar"><div class="progress-fill"></div></div>
                `;
                overlay.appendChild(progressEl);
            }
            progressEl.querySelector('.progress-text').textContent = message;
            progressEl.querySelector('.progress-fill').style.width = `${percent}%`;
        }

        // Step Navigation
        function goToStep(step) {
            if (step < 1 || step > 4) return;

            // Validation before moving forward
            if (step > state.currentStep) {
                if (state.currentStep === 1 && !state.pdfDoc) {
                    showToast('Please upload a PDF first');
                    return;
                }
                if (state.currentStep === 2 && state.recipients.filter(r => r.role === 'signer').length === 0) {
                    showToast('Please add at least one signer');
                    return;
                }
                // Warn (but don't block) if no signature fields when going to review
                if (state.currentStep === 3) {
                    const signers = state.recipients.filter(r => r.role === 'signer');
                    const signatureFields = state.placedFields.filter(f => f.type === 'signature');
                    if (signatureFields.length === 0) {
                        showToast('Warning: No signature fields placed. Signers won\'t be able to sign.');
                    } else {
                        // Check if each signer has at least one signature field
                        const signersWithoutFields = signers.filter(signer =>
                            !state.placedFields.some(f => f.type === 'signature' && f.recipientId === signer.id)
                        );
                        if (signersWithoutFields.length > 0) {
                            const names = signersWithoutFields.map(s => s.name).join(', ');
                            showToast(`Warning: ${names} has no signature field assigned.`);
                        }
                    }
                }
            }

            state.currentStep = step;
            updateStepUI();

            // Run step-specific logic
            if (step === 2) {
                renderPreview();
                setupAddMyselfCheckbox();
            } else if (step === 3) {
                populateRecipientSelector();
                renderAllPages();
                setFieldType('pointer'); // Start in pointer mode
            } else if (step === 4) {
                setFieldType('pointer'); // Bug #17 fix: Reset to pointer mode on Review step
                renderReview();
            }
        }

        function updateStepUI() {
            // Update stepper with ARIA attributes
            const stepLabels = ['Upload', 'Recipients', 'Fields', 'Review'];
            elements.steps.forEach((stepEl, index) => {
                const stepNum = index + 1;
                stepEl.classList.remove('active', 'completed');

                // Update aria-current for accessibility
                if (stepNum === state.currentStep) {
                    stepEl.classList.add('active');
                    stepEl.setAttribute('aria-current', 'step');
                    stepEl.setAttribute('aria-label', `Step ${stepNum}: ${stepLabels[index]}, current step`);
                } else if (stepNum < state.currentStep) {
                    stepEl.classList.add('completed');
                    stepEl.removeAttribute('aria-current');
                    stepEl.setAttribute('aria-label', `Step ${stepNum}: ${stepLabels[index]}, completed`);
                } else {
                    stepEl.removeAttribute('aria-current');
                    stepEl.setAttribute('aria-label', `Step ${stepNum}: ${stepLabels[index]}`);
                }
            });

            // Update connectors
            elements.stepConnectors.forEach((connector, index) => {
                connector.classList.toggle('completed', index < state.currentStep - 1);
            });

            // Update content
            elements.stepContents.forEach((content, index) => {
                content.classList.toggle('active', index + 1 === state.currentStep);
            });

            // Toggle full-width mode for step 3 (Fields placement needs more space)
            const mainContent = document.querySelector('.main-content');
            if (mainContent) {
                mainContent.classList.toggle('full-width', state.currentStep === 3);
            }

            // Update buttons
            elements.btnBack.classList.toggle('hidden', state.currentStep === 1);
            elements.btnNext.classList.toggle('hidden', state.currentStep >= 4);
            // Save Draft disabled until server-side persistence - always hidden
            // elements.btnSaveDraft.classList.toggle('hidden', state.currentStep === 1 || !state.storage);
            elements.btnSend.classList.toggle('hidden', state.currentStep !== 4);
            // Show generate links button on step 4, but not for remote signers
            elements.btnGenerateLinks.classList.toggle('hidden', state.currentStep !== 4 || state.remoteSession.isRemoteSigner);
            elements.btnDownload.classList.add('hidden');
        }

        // Check for incoming document from agentPDF via sessionStorage
        function checkForAgentPdfDocument() {
            const keys = {
                document: 'agentpdf_document',
                filename: 'agentpdf_filename',
                fields: 'agentpdf_fields',
                source: 'agentpdf_source',
                timestamp: 'agentpdf_timestamp'
            };

            const base64 = sessionStorage.getItem(keys.document);
            if (!base64) {
                return null;
            }

            // Check timestamp (expire after 5 minutes)
            const timestamp = parseInt(sessionStorage.getItem(keys.timestamp) || '0');
            const age = Date.now() - timestamp;
            if (age > 5 * 60 * 1000) {
                console.warn('Incoming document expired, clearing');
                Object.values(keys).forEach(key => sessionStorage.removeItem(key));
                return null;
            }

            try {
                // Decode base64 to Uint8Array
                const binary = atob(base64);
                const pdfBytes = new Uint8Array(binary.length);
                for (let i = 0; i < binary.length; i++) {
                    pdfBytes[i] = binary.charCodeAt(i);
                }

                const filename = sessionStorage.getItem(keys.filename) || 'document.pdf';
                const fieldsJson = sessionStorage.getItem(keys.fields);
                const fields = fieldsJson ? JSON.parse(fieldsJson) : [];

                // Clear sessionStorage after reading
                Object.values(keys).forEach(key => sessionStorage.removeItem(key));

                return { pdfBytes, filename, fields };
            } catch (err) {
                console.error('Failed to parse incoming document:', err);
                Object.values(keys).forEach(key => sessionStorage.removeItem(key));
                return null;
            }
        }

        // Load PDF from raw bytes (used for agentPDF handoff)
        async function loadPdfFromBytes(pdfBytes, filename, preplacedFields = []) {
            try {
                elements.loadingOverlay.classList.remove('hidden');

                state.pdfBytes = pdfBytes;
                state.pdfBytesForWorker = pdfBytes.slice();
                state.fileName = filename;

                // Create DocSign instance
                state.docSign = new DocSign();
                const loadResult = state.docSign.load_pdf(state.pdfBytes);
                if (loadResult && loadResult.error) {
                    throw new Error(loadResult.error);
                }
                state.docSign.log_view();

                // Update certificate indicator
                updateCertificateIndicator();

                // Load with PDF.js
                const loadingTask = pdfjsLib.getDocument({ data: state.pdfBytes });
                state.pdfDoc = await loadingTask.promise;
                state.totalPages = state.pdfDoc.numPages;

                // Cache page dimensions
                for (let i = 1; i <= state.totalPages; i++) {
                    try {
                        const page = await state.pdfDoc.getPage(i);
                        const viewport = page.getViewport({ scale: 1.0 });
                        state.cachedDimensions[i] = { width: viewport.width, height: viewport.height };
                    } catch (e) {
                        console.warn(`Failed to cache page ${i} dimensions:`, e);
                    }
                }

                // Render first page
                state.currentPage = 1;
                await renderPage(state.currentPage);

                // Update UI
                elements.docName.textContent = filename;
                elements.uploadScreen.classList.add('hidden');
                elements.editorScreen.classList.remove('hidden');
                state.currentStep = 2;
                updateStepUI();

                // Import pre-placed fields from agentPDF if any
                if (preplacedFields && preplacedFields.length > 0) {
                    console.log('Importing', preplacedFields.length, 'fields from agentPDF');
                    // Convert agentPDF field format to DocSign format
                    preplacedFields.forEach((field, idx) => {
                        const docSignField = {
                            id: 'imported-' + idx,
                            type: field.type || 'signature',
                            page: field.page || 1,
                            x: field.x || 100,
                            y: field.y || 100,
                            width: field.width || 200,
                            height: field.height || 50,
                            recipientId: null, // Will need to be assigned
                            required: true,
                            value: null
                        };
                        state.placedFields.push(docSignField);
                    });
                    // Re-render to show imported fields
                    await renderPage(state.currentPage);
                }

                elements.loadingOverlay.classList.add('hidden');
            } catch (err) {
                console.error('Failed to load PDF from bytes:', err);
                elements.loadingOverlay.classList.add('hidden');
                throw err;
            }
        }

        // File Upload
        // Constants for validation - must match backend MAX_PDF_SIZE in lib.rs (10MB)
        const MAX_PDF_SIZE_BYTES = 10 * 1024 * 1024; // 10 MB - matches backend
        const MAX_PDF_SIZE_MB = 10;
        // Warning threshold for multi-signer scenarios (signatures add overhead)
        const PDF_SIZE_WARNING_BYTES = 7 * 1024 * 1024; // 7 MB

        async function loadPDF(file) {
            try {
                // Bug #1: Validate file size BEFORE loading into memory
                if (file.size > MAX_PDF_SIZE_BYTES) {
                    const sizeMB = (file.size / (1024 * 1024)).toFixed(1);
                    if (window.DocSign && window.DocSign.showErrorModal) {
                        window.DocSign.showErrorModal({
                            title: 'File Is Too Large',
                            message: `This PDF is ${sizeMB}MB, but the maximum allowed size is ${MAX_PDF_SIZE_MB}MB. Please compress the document or split it into smaller files.`,
                            action: 'Choose Different File',
                            icon: 'file',
                            onAction: () => elements.fileInput.click()
                        });
                    } else {
                        alert(`PDF is too large (${sizeMB}MB). Maximum size is ${MAX_PDF_SIZE_MB}MB.`);
                    }
                    return;
                }

                // Warning for large PDFs that might have issues with many signers
                if (file.size > PDF_SIZE_WARNING_BYTES) {
                    const sizeMB = (file.size / (1024 * 1024)).toFixed(1);
                    showToast(`Note: This ${sizeMB}MB PDF is near the size limit. If you have many signers, consider compressing it.`, 5000);
                }

                elements.loadingOverlay.classList.remove('hidden');

                const arrayBuffer = await file.arrayBuffer();
                state.pdfBytes = new Uint8Array(arrayBuffer);
                state.pdfBytesForWorker = state.pdfBytes.slice();  // Save copy for worker
                state.fileName = file.name;

                // Create DocSign instance
                state.docSign = new DocSign();
                const loadResult = state.docSign.load_pdf(state.pdfBytes);
                if (loadResult && loadResult.error) {
                    throw new Error(loadResult.error);
                }
                state.docSign.log_view();

                // Update certificate indicator
                updateCertificateIndicator();

                // Load with PDF.js
                const loadingTask = pdfjsLib.getDocument({ data: state.pdfBytes });
                state.pdfDoc = await loadingTask.promise;
                state.totalPages = state.pdfDoc.numPages;

                // Cache page dimensions
                for (let i = 1; i <= state.totalPages; i++) {
                    try {
                        const dims = state.docSign.page_dimensions(i);
                        state.pageDimensions[i] = {
                            width: dims.width,
                            height: dims.height
                        };
                    } catch (e) {
                        console.warn(`Could not get dimensions for page ${i}:`, e);
                        // Fallback to PDF.js dimensions
                        const page = await state.pdfDoc.getPage(i);
                        const viewport = page.getViewport({ scale: 1 });
                        state.pageDimensions[i] = {
                            width: viewport.width,
                            height: viewport.height
                        };
                    }
                }

                // Initialize signing worker with PDF (optional - falls back to main thread)
                try {
                    if (signingWorker) {
                        signingWorker.terminate();
                        signingWorker = null;
                    }
                    signingWorker = new SigningWorker();
                    await Promise.race([
                        signingWorker.init(),
                        new Promise((_, reject) => setTimeout(() => reject(new Error('Worker init timeout')), 5000))
                    ]);
                    await Promise.race([
                        signingWorker.loadPdf(state.pdfBytesForWorker),
                        new Promise((_, reject) => setTimeout(() => reject(new Error('Worker load timeout')), 5000))
                    ]);
                    console.log('Signing worker initialized with PDF');
                } catch (workerErr) {
                    console.warn('Worker init failed, using main thread:', workerErr.message);
                    if (signingWorker) {
                        signingWorker.terminate();
                        signingWorker = null;
                    }
                }

                // Update UI
                elements.docName.textContent = state.fileName;
                elements.totalPagesSpan.textContent = state.totalPages;

                elements.loadingOverlay.classList.add('hidden');
                showToast('PDF loaded successfully');

                // Move to next step
                goToStep(2);
            } catch (err) {
                console.error('Failed to load PDF:', err);
                elements.loadingOverlay.classList.add('hidden');
                showToast(getPdfErrorMessage(err.message || err));
            }
        }

        // Recipients - Add Myself as Signer
        function setupAddMyselfCheckbox() {
            const checkbox = document.getElementById('add-myself-checkbox');
            const section = document.getElementById('add-myself-section');
            if (!checkbox || !section) return;

            // Get current user info
            const currentUser = window.DocSign?.getCurrentUser?.();
            const userNames = JSON.parse(localStorage.getItem('docsign_user_names') || '{}');

            // If no user logged in, hide the section
            if (!currentUser) {
                section.style.display = 'none';
                return;
            }

            section.style.display = 'block';

            // Check if user already added as recipient - sync checkbox state
            const userAlreadyAdded = state.recipients.some(r => r.email === currentUser.email);
            checkbox.checked = userAlreadyAdded; // Only checked if user manually added themselves

            // Add event listener (remove any existing to avoid duplicates)
            checkbox.removeEventListener('change', handleAddMyselfChange);
            checkbox.addEventListener('change', handleAddMyselfChange);

            // No auto-add - user must click checkbox to add themselves
        }

        function handleAddMyselfChange(e) {
            const currentUser = window.DocSign?.getCurrentUser?.();
            if (!currentUser) return;

            if (e.target.checked) {
                // Add user if not already added
                const userAlreadyAdded = state.recipients.some(r => r.email === currentUser.email);
                if (!userAlreadyAdded) {
                    addMyselfAsRecipient();
                }
            } else {
                // Remove user from recipients
                state.recipients = state.recipients.filter(r => r.email !== currentUser.email);
                renderRecipientList();
            }
        }

        function addMyselfAsRecipient() {
            const currentUser = window.DocSign?.getCurrentUser?.();
            if (!currentUser) return;

            // Get individual name fields if available
            const userNames = JSON.parse(localStorage.getItem('docsign_user_names') || '{}');
            let firstName = userNames.firstName || '';
            let lastName = userNames.lastName || '';

            // Fallback: parse from full name
            if (!firstName && currentUser.name) {
                const nameParts = currentUser.name.trim().split(/\s+/);
                firstName = nameParts[0] || '';
                lastName = nameParts.slice(1).join(' ') || '';
            }

            const fullName = currentUser.name || `${firstName} ${lastName}`.trim();

            // Add as first recipient (signer)
            state.recipients.unshift({
                id: Date.now(),
                firstName,
                lastName,
                name: fullName,
                email: currentUser.email,
                role: 'signer',
                order: 1,
                color: recipientColors[0],
                isCurrentUser: true
            });

            // Update order numbers for other recipients
            state.recipients.forEach((r, i) => {
                r.order = i + 1;
                r.color = recipientColors[i % recipientColors.length];
            });

            renderRecipientList();
        }

        // Recipients - Manual Add
        // Bug #1: Maximum recipient limit (matches docsign-core/validation.rs)
        const MAX_RECIPIENTS = 10;

        function addRecipient() {
            // Bug #1: Check recipient limit BEFORE adding
            if (state.recipients.length >= MAX_RECIPIENTS) {
                if (window.DocSign && window.DocSign.showErrorModal) {
                    window.DocSign.showErrorModal({
                        title: 'Too Many Recipients',
                        message: `You can add up to ${MAX_RECIPIENTS} people to sign a document. Please remove some recipients or create separate signing requests for additional signers.`,
                        action: 'OK',
                        icon: 'user'
                    });
                } else {
                    alert(`Maximum ${MAX_RECIPIENTS} recipients allowed.`);
                }
                return;
            }

            const firstName = elements.recipientFirstName.value.trim();
            const lastName = elements.recipientLastName.value.trim();
            const email = elements.recipientEmail.value.trim();
            const role = elements.recipientRole.value;

            if (!firstName || !lastName || !email) {
                showToast('Please enter first name, last name, and email');
                return;
            }

            if (!email.includes('@')) {
                showToast('Please enter a valid email');
                return;
            }

            const fullName = `${firstName} ${lastName}`;
            state.recipients.push({
                id: Date.now(),
                firstName,
                lastName,
                name: fullName, // Keep for backward compatibility
                email,
                role,
                order: state.recipients.length + 1,
                color: recipientColors[state.recipients.length % recipientColors.length]
            });

            // Clear inputs
            elements.recipientFirstName.value = '';
            elements.recipientLastName.value = '';
            elements.recipientEmail.value = '';

            renderRecipientList();
            showToast(`${fullName} added`);
        }

        function removeRecipient(id) {
            state.recipients = state.recipients.filter(r => r.id !== id);
            // Update order
            state.recipients.forEach((r, i) => r.order = i + 1);
            // Remove fields for this recipient
            state.placedFields = state.placedFields.filter(f => f.recipientId !== id);
            renderRecipientList();
        }

        function moveRecipient(id, direction) {
            const index = state.recipients.findIndex(r => r.id === id);
            if (index === -1) return;

            const newIndex = index + direction;
            if (newIndex < 0 || newIndex >= state.recipients.length) return;

            // Swap
            [state.recipients[index], state.recipients[newIndex]] =
            [state.recipients[newIndex], state.recipients[index]];

            // Update order
            state.recipients.forEach((r, i) => r.order = i + 1);
            renderRecipientList();
        }

        function renderRecipientList() {
            if (state.recipients.length === 0) {
                elements.recipientList.innerHTML = `
                    <li style="text-align: center; color: #9ca3af; padding: 1rem; cursor: default;">
                        No recipients added yet
                    </li>
                `;
                return;
            }

            elements.recipientList.innerHTML = state.recipients.map((r, index) => `
                <li class="recipient-item" data-id="${r.id}" data-index="${index}" draggable="true">
                    <div class="recipient-drag-handle" title="Drag to reorder">â‹®â‹®</div>
                    <div class="recipient-order" style="background: ${r.color}">${r.order}</div>
                    <div class="recipient-info">
                        <div class="recipient-name">${r.name}</div>
                        <div class="recipient-email">${r.email} (${r.role === 'signer' ? 'Signs' : 'Copy'})</div>
                    </div>
                    <div class="recipient-actions">
                        <button onclick="event.stopPropagation(); window.removeRecipient(${r.id})" title="Remove">âœ•</button>
                    </div>
                </li>
            `).join('');

            // Setup drag handlers after rendering
            setupRecipientDragHandlers();
        }

        // Drag-to-reorder state (kept separate to avoid re-renders during drag)
        const dragState = {
            isDragging: false,
            draggedElement: null,
            draggedIndex: null,
            targetIndex: null,
            placeholder: null,
            startY: 0,
            currentY: 0
        };

        function setupRecipientDragHandlers() {
            const items = elements.recipientList.querySelectorAll('.recipient-item[draggable="true"]');

            items.forEach(item => {
                item.addEventListener('dragstart', handleDragStart);
                item.addEventListener('dragend', handleDragEnd);
                item.addEventListener('dragover', handleDragOver);
                item.addEventListener('dragleave', handleDragLeave);
                item.addEventListener('drop', handleDrop);
            });
        }

        function handleDragStart(e) {
            const item = e.currentTarget;
            dragState.isDragging = true;
            dragState.draggedElement = item;
            dragState.draggedIndex = parseInt(item.dataset.index);

            // Set drag image (use the element itself)
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', dragState.draggedIndex.toString());

            // Apply dragging style after a tiny delay (so drag image captures properly)
            requestAnimationFrame(() => {
                item.classList.add('dragging');
            });
        }

        function handleDragEnd(e) {
            const item = e.currentTarget;
            item.classList.remove('dragging');

            // Clear all drag-over classes
            elements.recipientList.querySelectorAll('.recipient-item').forEach(el => {
                el.classList.remove('drag-over-above', 'drag-over-below', 'drag-ghost');
            });

            // Remove placeholder if exists
            const placeholder = elements.recipientList.querySelector('.drag-placeholder');
            if (placeholder) {
                placeholder.remove();
            }

            // Perform the reorder if we have a valid target
            if (dragState.isDragging && dragState.targetIndex !== null && dragState.targetIndex !== dragState.draggedIndex) {
                reorderRecipients(dragState.draggedIndex, dragState.targetIndex);
            }

            // Reset drag state
            dragState.isDragging = false;
            dragState.draggedElement = null;
            dragState.draggedIndex = null;
            dragState.targetIndex = null;
        }

        function handleDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';

            if (!dragState.isDragging) return;

            const item = e.currentTarget;
            const targetIndex = parseInt(item.dataset.index);

            if (targetIndex === dragState.draggedIndex) return;

            // Determine if we're in the top or bottom half of the target
            const rect = item.getBoundingClientRect();
            const midpoint = rect.top + rect.height / 2;
            const isAbove = e.clientY < midpoint;

            // Clear previous indicators
            elements.recipientList.querySelectorAll('.recipient-item').forEach(el => {
                if (el !== dragState.draggedElement) {
                    el.classList.remove('drag-over-above', 'drag-over-below');
                }
            });

            // Add indicator to current target
            if (isAbove) {
                item.classList.add('drag-over-above');
                item.classList.remove('drag-over-below');
                dragState.targetIndex = targetIndex;
            } else {
                item.classList.add('drag-over-below');
                item.classList.remove('drag-over-above');
                dragState.targetIndex = targetIndex + 1;
            }

            // Adjust if moving down
            if (dragState.targetIndex > dragState.draggedIndex) {
                dragState.targetIndex = targetIndex;
            } else {
                dragState.targetIndex = targetIndex;
            }
        }

        function handleDragLeave(e) {
            const item = e.currentTarget;
            // Only remove if we're actually leaving (not entering a child)
            if (!item.contains(e.relatedTarget)) {
                item.classList.remove('drag-over-above', 'drag-over-below');
            }
        }

        function handleDrop(e) {
            e.preventDefault();
            // The actual reorder happens in dragEnd to ensure clean state
        }

        function reorderRecipients(fromIndex, toIndex) {
            if (fromIndex === toIndex) return;

            // Remove from old position and insert at new position
            const [moved] = state.recipients.splice(fromIndex, 1);

            // Adjust toIndex if we removed from before it
            const adjustedToIndex = fromIndex < toIndex ? toIndex - 1 : toIndex;

            state.recipients.splice(adjustedToIndex, 0, moved);

            // Update order numbers
            state.recipients.forEach((r, i) => r.order = i + 1);

            // Re-render the list (single render at end of drag)
            renderRecipientList();
        }

        // Expose to window for inline handlers
        window.removeRecipient = removeRecipient;
        window.moveRecipient = moveRecipient;

        // PDF Preview (Step 2) - All pages with zoom and navigation
        const previewState = {
            zoom: 1.0, // 100%
            currentPage: 1,
            minZoom: 0.25,
            maxZoom: 4.0  // Bug #13: Extended from 300% to 400%
        };

        async function renderPreview() {
            if (!state.pdfDoc) return;

            const container = elements.previewContainer;
            container.innerHTML = '';

            // Render all pages for scrolling
            for (let pageNum = 1; pageNum <= state.totalPages; pageNum++) {
                const page = await state.pdfDoc.getPage(pageNum);
                const baseScale = 0.5; // Base scale for preview
                const viewport = page.getViewport({ scale: baseScale * previewState.zoom });

                const pageDiv = document.createElement('div');
                pageDiv.className = 'preview-page';
                pageDiv.dataset.page = pageNum;
                pageDiv.style.cssText = `
                    margin-bottom: 0.5rem;
                    background: white;
                    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
                `;

                const canvas = document.createElement('canvas');
                canvas.width = viewport.width;
                canvas.height = viewport.height;
                canvas.style.display = 'block';

                pageDiv.appendChild(canvas);
                container.appendChild(pageDiv);

                // Render in background for performance
                page.render({
                    canvasContext: canvas.getContext('2d'),
                    viewport
                }).promise;
            }

            updatePreviewUI();

            // Bug #11: Add floating scroll navigation buttons
            setupScrollNavButtons(container, 'preview');

            // Bug #12: Setup editable page input
            const pageIndicator = document.getElementById('preview-page-indicator');
            if (pageIndicator && !pageIndicator.dataset.editableSetup) {
                setupEditablePageInput(
                    pageIndicator,
                    previewState,
                    scrollToPreviewPage,
                    () => state.totalPages
                );
            }

            // Bug #13: Add Ctrl+scroll zoom for desktop
            setupCtrlScrollZoom(container, previewState, renderPreview);
        }

        function updatePreviewUI() {
            const zoomLevel = document.getElementById('preview-zoom-level');
            const pageIndicator = document.getElementById('preview-page-indicator');
            const prevBtn = document.getElementById('preview-prev-page');
            const nextBtn = document.getElementById('preview-next-page');

            if (zoomLevel) {
                zoomLevel.textContent = Math.round(previewState.zoom * 100) + '%';
            }
            if (pageIndicator) {
                // Check if editable page input is setup (Bug #12)
                if (pageIndicator._updateDisplay) {
                    pageIndicator._updateDisplay(previewState.currentPage, state.totalPages || 1);
                } else {
                    // Fallback for when editable hasn't been setup yet
                    const currentSpan = pageIndicator.querySelector('.current-page');
                    const totalSpan = pageIndicator.querySelector('.total-pages');
                    if (currentSpan && totalSpan) {
                        currentSpan.textContent = previewState.currentPage;
                        totalSpan.textContent = state.totalPages || 1;
                    } else {
                        pageIndicator.textContent = `${previewState.currentPage} / ${state.totalPages || 1}`;
                    }
                }
            }
            if (prevBtn) {
                prevBtn.disabled = previewState.currentPage <= 1;
            }
            if (nextBtn) {
                nextBtn.disabled = previewState.currentPage >= state.totalPages;
            }
        }

        function setupPreviewControls() {
            const zoomIn = document.getElementById('preview-zoom-in');
            const zoomOut = document.getElementById('preview-zoom-out');
            const prevPage = document.getElementById('preview-prev-page');
            const nextPage = document.getElementById('preview-next-page');

            if (zoomIn) {
                zoomIn.onclick = () => {
                    if (previewState.zoom < previewState.maxZoom) {
                        previewState.zoom = Math.min(previewState.maxZoom, previewState.zoom + 0.25);
                        renderPreview();
                    }
                };
            }
            if (zoomOut) {
                zoomOut.onclick = () => {
                    if (previewState.zoom > previewState.minZoom) {
                        previewState.zoom = Math.max(previewState.minZoom, previewState.zoom - 0.25);
                        renderPreview();
                    }
                };
            }
            if (prevPage) {
                prevPage.onclick = () => {
                    if (previewState.currentPage > 1) {
                        previewState.currentPage--;
                        scrollToPreviewPage(previewState.currentPage);
                        updatePreviewUI();
                    }
                };
            }
            if (nextPage) {
                nextPage.onclick = () => {
                    if (previewState.currentPage < state.totalPages) {
                        previewState.currentPage++;
                        scrollToPreviewPage(previewState.currentPage);
                        updatePreviewUI();
                    }
                };
            }
        }

        function scrollToPreviewPage(pageNum) {
            const container = elements.previewContainer;
            const pageDiv = container.querySelector(`[data-page="${pageNum}"]`);
            if (pageDiv) {
                pageDiv.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }
        }

        // Initialize preview controls on DOM ready
        document.addEventListener('DOMContentLoaded', setupPreviewControls);

        // ============================================================
        // Scroll Tracking - Updates page number when user scrolls
        // ============================================================

        function setupPreviewScrollTracking() {
            const container = elements.previewContainer;
            if (!container) return;

            // Use IntersectionObserver to track which page is currently visible
            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting && entry.intersectionRatio > 0.5) {
                        const pageNum = parseInt(entry.target.dataset.page);
                        if (pageNum && pageNum !== previewState.currentPage) {
                            previewState.currentPage = pageNum;
                            updatePreviewUI();
                        }
                    }
                });
            }, {
                root: container,
                threshold: 0.5
            });

            // Observe all page divs when they're added
            const observePages = () => {
                container.querySelectorAll('[data-page]').forEach(page => {
                    observer.observe(page);
                });
            };

            // Initial observation and re-observe when content changes
            observePages();

            // Re-observe when new pages are rendered
            const mutationObserver = new MutationObserver(observePages);
            mutationObserver.observe(container, { childList: true, subtree: true });
        }

        // Step 3 (Fields) Zoom Controls
        const fieldsZoomState = {
            zoom: 1.0,
            minZoom: 0.5,
            maxZoom: 4.0  // Bug #13: Extended from 300% to 400%
        };

        function setupFieldsZoomControls() {
            const zoomIn = document.getElementById('fields-zoom-in');
            const zoomOut = document.getElementById('fields-zoom-out');
            const zoomLevel = document.getElementById('fields-zoom-level');

            if (zoomIn) {
                zoomIn.onclick = async () => {
                    if (fieldsZoomState.zoom < fieldsZoomState.maxZoom) {
                        fieldsZoomState.zoom = Math.min(fieldsZoomState.maxZoom, fieldsZoomState.zoom + 0.25);
                        state.scale = fieldsZoomState.zoom * 1.5; // Base scale is 1.5
                        updateFieldsZoomUI();
                        await renderAllPages();
                    }
                };
            }
            if (zoomOut) {
                zoomOut.onclick = async () => {
                    if (fieldsZoomState.zoom > fieldsZoomState.minZoom) {
                        fieldsZoomState.zoom = Math.max(fieldsZoomState.minZoom, fieldsZoomState.zoom - 0.25);
                        state.scale = fieldsZoomState.zoom * 1.5; // Base scale is 1.5
                        updateFieldsZoomUI();
                        await renderAllPages();
                    }
                };
            }
        }

        function updateFieldsZoomUI() {
            const zoomLevel = document.getElementById('fields-zoom-level');
            if (zoomLevel) {
                zoomLevel.textContent = Math.round(fieldsZoomState.zoom * 100) + '%';
            }
        }

        function setupFieldsScrollTracking() {
            const container = elements.pdfCanvasContainer;
            if (!container) return;

            // Use IntersectionObserver to track which page is visible in Fields editor
            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting && entry.intersectionRatio > 0.3) {
                        const pageNum = parseInt(entry.target.dataset.page);
                        if (pageNum && pageNum !== state.currentPage) {
                            state.currentPage = pageNum;
                            updatePageNav();
                        }
                    }
                });
            }, {
                root: container,
                threshold: 0.3
            });

            // Observe page wrappers
            const observePages = () => {
                container.querySelectorAll('.pdf-page-wrapper[data-page]').forEach(page => {
                    observer.observe(page);
                });
            };

            observePages();

            // Re-observe when pages are re-rendered
            const mutationObserver = new MutationObserver(observePages);
            mutationObserver.observe(container, { childList: true, subtree: true });
        }

        // ============================================================
        // Pinch-to-Zoom Support for Mobile
        // ============================================================

        function setupPinchToZoom() {
            const container = elements.previewContainer;
            if (!container) return;

            let initialDistance = 0;
            let initialZoom = 1;

            container.addEventListener('touchstart', (e) => {
                if (e.touches.length === 2) {
                    initialDistance = Math.hypot(
                        e.touches[0].clientX - e.touches[1].clientX,
                        e.touches[0].clientY - e.touches[1].clientY
                    );
                    initialZoom = previewState.zoom;
                }
            }, { passive: true });

            container.addEventListener('touchmove', (e) => {
                if (e.touches.length === 2) {
                    const currentDistance = Math.hypot(
                        e.touches[0].clientX - e.touches[1].clientX,
                        e.touches[0].clientY - e.touches[1].clientY
                    );

                    const scale = currentDistance / initialDistance;
                    const newZoom = Math.max(
                        previewState.minZoom,
                        Math.min(previewState.maxZoom, initialZoom * scale)
                    );

                    if (Math.abs(newZoom - previewState.zoom) > 0.05) {
                        previewState.zoom = newZoom;
                        updatePreviewUI();
                        // Debounce re-render for performance
                        clearTimeout(container._pinchRenderTimeout);
                        container._pinchRenderTimeout = setTimeout(() => {
                            renderPreview();
                        }, 150);
                    }
                }
            }, { passive: true });
        }

        // ============================================================
        // Review Page Preview Controls (Step 4)
        // ============================================================

        const reviewState = {
            zoom: 1.0,
            currentPage: 1,
            minZoom: 0.25,
            maxZoom: 4.0  // Bug #13: Extended from 300% to 400%
        };

        function setupReviewControls() {
            const zoomIn = document.getElementById('review-zoom-in');
            const zoomOut = document.getElementById('review-zoom-out');
            const prevPage = document.getElementById('review-prev-page');
            const nextPage = document.getElementById('review-next-page');

            if (zoomIn) {
                zoomIn.onclick = () => {
                    if (reviewState.zoom < reviewState.maxZoom) {
                        reviewState.zoom = Math.min(reviewState.maxZoom, reviewState.zoom + 0.25);
                        renderReview();
                    }
                };
            }
            if (zoomOut) {
                zoomOut.onclick = () => {
                    if (reviewState.zoom > reviewState.minZoom) {
                        reviewState.zoom = Math.max(reviewState.minZoom, reviewState.zoom - 0.25);
                        renderReview();
                    }
                };
            }
            if (prevPage) {
                prevPage.onclick = () => {
                    if (reviewState.currentPage > 1) {
                        reviewState.currentPage--;
                        scrollToReviewPage(reviewState.currentPage);
                        updateReviewUI();
                    }
                };
            }
            if (nextPage) {
                nextPage.onclick = () => {
                    if (reviewState.currentPage < state.totalPages) {
                        reviewState.currentPage++;
                        scrollToReviewPage(reviewState.currentPage);
                        updateReviewUI();
                    }
                };
            }
        }

        function updateReviewUI() {
            const zoomLevel = document.getElementById('review-zoom-level');
            const pageIndicator = document.getElementById('review-page-indicator');
            const prevBtn = document.getElementById('review-prev-page');
            const nextBtn = document.getElementById('review-next-page');

            if (zoomLevel) {
                zoomLevel.textContent = Math.round(reviewState.zoom * 100) + '%';
            }
            if (pageIndicator) {
                // Check if editable page input is setup (Bug #12)
                if (pageIndicator._updateDisplay) {
                    pageIndicator._updateDisplay(reviewState.currentPage, state.totalPages || 1);
                } else {
                    // Fallback for when editable hasn't been setup yet
                    const currentSpan = pageIndicator.querySelector('.current-page');
                    const totalSpan = pageIndicator.querySelector('.total-pages');
                    if (currentSpan && totalSpan) {
                        currentSpan.textContent = reviewState.currentPage;
                        totalSpan.textContent = state.totalPages || 1;
                    } else {
                        pageIndicator.textContent = `${reviewState.currentPage} / ${state.totalPages || 1}`;
                    }
                }
            }
            if (prevBtn) {
                prevBtn.disabled = reviewState.currentPage <= 1;
            }
            if (nextBtn) {
                nextBtn.disabled = reviewState.currentPage >= state.totalPages;
            }
        }

        function scrollToReviewPage(pageNum) {
            const container = elements.reviewPdfBody;
            if (!container) return;
            const pageDiv = container.querySelector(`[data-page="${pageNum}"]`);
            if (pageDiv) {
                pageDiv.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }
        }

        function setupReviewScrollTracking() {
            const container = elements.reviewPdfBody;
            if (!container) return;

            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting && entry.intersectionRatio > 0.3) {
                        const pageNum = parseInt(entry.target.dataset.page);
                        if (pageNum && pageNum !== reviewState.currentPage) {
                            reviewState.currentPage = pageNum;
                            updateReviewUI();
                        }
                    }
                });
            }, {
                root: container,
                threshold: 0.3
            });

            const observePages = () => {
                container.querySelectorAll('[data-page]').forEach(page => {
                    observer.observe(page);
                });
            };

            observePages();
            const mutationObserver = new MutationObserver(observePages);
            mutationObserver.observe(container, { childList: true, subtree: true });
        }

        // ============================================================
        // Bug #11: Floating Jump Navigation Buttons
        // ============================================================

        /**
         * Add floating jump-to-top/bottom buttons to a scrollable container
         * @param {HTMLElement} container - The scrollable container
         * @param {string} containerId - Unique ID for this container's buttons
         */
        function setupScrollNavButtons(container, containerId) {
            if (!container) return;

            // Check if buttons already exist
            if (container.querySelector('.scroll-nav-buttons')) return;

            // Create button group
            const buttonGroup = document.createElement('div');
            buttonGroup.className = 'scroll-nav-buttons';
            buttonGroup.id = `scroll-nav-${containerId}`;
            buttonGroup.innerHTML = `
                <button class="scroll-nav-btn hidden" id="jump-top-${containerId}"
                        aria-label="Jump to top of document" title="Jump to top">
                    <span aria-hidden="true">â†‘</span>
                </button>
                <button class="scroll-nav-btn" id="jump-bottom-${containerId}"
                        aria-label="Jump to bottom of document" title="Jump to bottom">
                    <span aria-hidden="true">â†“</span>
                </button>
            `;

            // Ensure container has position relative for absolute positioning
            const containerStyle = getComputedStyle(container);
            if (containerStyle.position === 'static') {
                container.style.position = 'relative';
            }

            container.appendChild(buttonGroup);

            const topBtn = buttonGroup.querySelector(`#jump-top-${containerId}`);
            const bottomBtn = buttonGroup.querySelector(`#jump-bottom-${containerId}`);

            // Update button visibility based on scroll position
            const updateButtonVisibility = () => {
                const scrollTop = container.scrollTop;
                const scrollHeight = container.scrollHeight;
                const clientHeight = container.clientHeight;
                const scrollBottom = scrollHeight - scrollTop - clientHeight;

                // Show "top" button when scrolled past first screen (100px threshold)
                topBtn.classList.toggle('hidden', scrollTop < 100);

                // Show "bottom" button when not at the end (100px threshold)
                bottomBtn.classList.toggle('hidden', scrollBottom < 100);
            };

            // Scroll handlers
            topBtn.onclick = () => {
                container.scrollTo({ top: 0, behavior: 'smooth' });
            };

            bottomBtn.onclick = () => {
                container.scrollTo({ top: container.scrollHeight, behavior: 'smooth' });
            };

            // Listen for scroll events
            container.addEventListener('scroll', updateButtonVisibility, { passive: true });

            // Initial visibility check
            updateButtonVisibility();

            // Re-check after content loads (images, etc.)
            setTimeout(updateButtonVisibility, 500);
        }

        // ============================================================
        // Bug #12: Editable Page Number Input
        // ============================================================

        /**
         * Make page indicator clickable to jump to a specific page
         * @param {HTMLElement} indicatorWrapper - The wrapper containing the page indicator
         * @param {object} stateObj - State object with currentPage property
         * @param {function} scrollFn - Function to scroll to a page number
         * @param {function} getTotalPages - Function to get total page count
         */
        function setupEditablePageInput(indicatorWrapper, stateObj, scrollFn, getTotalPages) {
            if (!indicatorWrapper) return;

            // Check if already setup
            if (indicatorWrapper.dataset.editableSetup) return;
            indicatorWrapper.dataset.editableSetup = 'true';

            // Get the existing span and convert to editable structure
            const existingText = indicatorWrapper.textContent.trim();
            const [current, total] = existingText.split('/').map(s => s.trim());

            indicatorWrapper.innerHTML = `
                <button class="page-input-trigger" aria-label="Click to jump to a specific page" title="Click to jump to page">
                    <span class="current-page">${current || '1'}</span> / <span class="total-pages">${total || '1'}</span>
                </button>
                <input type="number" class="page-input hidden" min="1" aria-label="Enter page number to jump to">
            `;
            indicatorWrapper.classList.add('page-indicator-wrapper');

            const trigger = indicatorWrapper.querySelector('.page-input-trigger');
            const input = indicatorWrapper.querySelector('.page-input');
            const currentSpan = indicatorWrapper.querySelector('.current-page');
            const totalSpan = indicatorWrapper.querySelector('.total-pages');

            // Store references for external updates
            indicatorWrapper._updateDisplay = (currentPage, totalPages) => {
                currentSpan.textContent = currentPage;
                totalSpan.textContent = totalPages;
            };

            trigger.onclick = (e) => {
                e.preventDefault();
                const totalPages = getTotalPages();
                input.max = totalPages;
                input.value = stateObj.currentPage || 1;
                trigger.classList.add('hidden');
                input.classList.remove('hidden');
                input.focus();
                input.select();
            };

            const commit = () => {
                const totalPages = getTotalPages();
                const value = parseInt(input.value) || 1;
                // Clamp to valid range
                const clamped = Math.max(1, Math.min(totalPages, value));

                // Update state and scroll
                stateObj.currentPage = clamped;
                scrollFn(clamped);

                // Update display
                currentSpan.textContent = clamped;

                trigger.classList.remove('hidden');
                input.classList.add('hidden');
            };

            input.onkeydown = (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    commit();
                }
                if (e.key === 'Escape') {
                    trigger.classList.remove('hidden');
                    input.classList.add('hidden');
                }
            };

            input.onblur = () => {
                // Small delay to allow click events to process first
                setTimeout(() => {
                    if (!input.classList.contains('hidden')) {
                        commit();
                    }
                }, 100);
            };
        }

        // ============================================================
        // Bug #13: Ctrl+Scroll Zoom for Desktop
        // ============================================================

        /**
         * Add Ctrl+scroll zoom to a container
         * @param {HTMLElement} container - The scrollable container
         * @param {object} zoomState - State object with zoom, minZoom, maxZoom properties
         * @param {function} onZoom - Callback to re-render after zoom change
         */
        function setupCtrlScrollZoom(container, zoomState, onZoom) {
            if (!container || container.dataset.ctrlScrollSetup) return;
            container.dataset.ctrlScrollSetup = 'true';

            container.addEventListener('wheel', (e) => {
                // Only handle Ctrl+scroll (or Cmd+scroll on Mac)
                if (!e.ctrlKey && !e.metaKey) return;

                e.preventDefault();

                const delta = e.deltaY;
                const zoomStep = 0.1; // 10% per scroll step

                if (delta < 0) {
                    // Scroll up = zoom in
                    if (zoomState.zoom < zoomState.maxZoom) {
                        zoomState.zoom = Math.min(zoomState.maxZoom, zoomState.zoom + zoomStep);
                        onZoom();
                    }
                } else if (delta > 0) {
                    // Scroll down = zoom out
                    if (zoomState.zoom > zoomState.minZoom) {
                        zoomState.zoom = Math.max(zoomState.minZoom, zoomState.zoom - zoomStep);
                        onZoom();
                    }
                }
            }, { passive: false });
        }

        // Initialize scroll tracking on DOM ready
        document.addEventListener('DOMContentLoaded', () => {
            setupPreviewScrollTracking();
            setupFieldsZoomControls();
            setupFieldsScrollTracking();
            setupPinchToZoom();
            setupReviewControls();
            setupReviewScrollTracking();

            // Bug #11: Add floating navigation buttons to all preview containers
            // Will be called after containers are populated
        });

        // PDF Editor (Step 3) - Render ALL pages for scrolling
        function populateRecipientSelector() {
            const signers = state.recipients.filter(r => r.role === 'signer');
            elements.currentRecipient.innerHTML = signers.map((r, i) => `
                <option value="${r.id}" style="color: ${r.color}">${r.order}. ${r.name}</option>
            `).join('');
        }

        async function renderAllPages() {
            if (!state.pdfDoc) return;

            elements.pdfPagesWrapper.innerHTML = '';

            for (let pageNum = 1; pageNum <= state.totalPages; pageNum++) {
                const page = await state.pdfDoc.getPage(pageNum);
                const viewport = page.getViewport({ scale: state.scale });

                const pageWrapper = document.createElement('div');
                pageWrapper.className = 'pdf-page-wrapper';
                pageWrapper.dataset.page = pageNum;
                pageWrapper.style.width = viewport.width + 'px';
                pageWrapper.style.height = viewport.height + 'px';

                const canvas = document.createElement('canvas');
                canvas.width = viewport.width;
                canvas.height = viewport.height;

                pageWrapper.appendChild(canvas);
                elements.pdfPagesWrapper.appendChild(pageWrapper);

                await page.render({
                    canvasContext: canvas.getContext('2d'),
                    viewport
                }).promise;

                // Store canvas dimensions for coordinate conversion
                state.pageDimensions[pageNum] = {
                    ...state.pageDimensions[pageNum],
                    canvasWidth: viewport.width,
                    canvasHeight: viewport.height
                };

                // Add click handler for field placement
                pageWrapper.addEventListener('click', (e) => handlePageClick(e, pageNum, pageWrapper));
            }

            renderPlacedFields();
            updatePageNav();

            // Bug #11: Add floating scroll navigation buttons to the canvas container
            setupScrollNavButtons(elements.pdfCanvasContainer, 'fields');

            // Bug #13: Add Ctrl+scroll zoom for desktop
            setupCtrlScrollZoom(elements.pdfCanvasContainer, fieldsZoomState, renderAllPages);
        }

        function updatePageNav() {
            // Update page navigation to scroll to page
            elements.currentPageSpan.textContent = state.currentPage;
            elements.prevPageBtn.disabled = state.currentPage <= 1;
            elements.nextPageBtn.disabled = state.currentPage >= state.totalPages;
        }

        function scrollToPage(pageNum) {
            const pageWrapper = elements.pdfPagesWrapper.querySelector(`[data-page="${pageNum}"]`);
            if (pageWrapper) {
                pageWrapper.scrollIntoView({ behavior: 'smooth', block: 'start' });
                state.currentPage = pageNum;
                updatePageNav();
            }
        }

        // Field Placement with Click-to-Attach UX
        function setupFieldPlacement() {
            // Handle field type selection
            elements.fieldTypes.forEach(fieldType => {
                fieldType.addEventListener('click', () => {
                    const type = fieldType.dataset.type;
                    setFieldType(type);
                });
            });

            // Handle mouse move for ghost field
            document.addEventListener('mousemove', (e) => {
                if (state.selectedFieldType && state.selectedFieldType !== 'pointer') {
                    elements.ghostField.style.left = (e.clientX + 10) + 'px';
                    elements.ghostField.style.top = (e.clientY + 10) + 'px';
                }
            });

            // Handle Escape key to cancel placement
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && state.selectedFieldType && state.selectedFieldType !== 'pointer') {
                    setFieldType('pointer');
                    showToast('Field placement cancelled');
                }
            });
        }

        function setFieldType(type) {
            state.selectedFieldType = type;

            // Update UI and aria-pressed for accessibility
            elements.fieldTypes.forEach(ft => {
                const isSelected = ft.dataset.type === type;
                ft.classList.toggle('selected', isSelected);
                ft.setAttribute('aria-pressed', isSelected ? 'true' : 'false');
            });

            // Update "Required Field" checkbox based on field type
            // Signature fields are always required, others default to checked but can be changed
            if (type === 'signature') {
                elements.fieldRequired.checked = true;
                elements.fieldRequired.disabled = true; // Can't uncheck signature fields
            } else if (type && type !== 'pointer') {
                elements.fieldRequired.disabled = false;
                // Keep current state for other fields
            }

            // Update ghost field
            if (type && type !== 'pointer') {
                elements.ghostField.textContent = getFieldLabel(type);
                elements.ghostField.classList.remove('hidden');
                elements.placementHint.classList.add('active');

                // Update page wrappers cursor
                document.querySelectorAll('.pdf-page-wrapper').forEach(pw => {
                    pw.classList.add('placement-mode');
                });
            } else {
                elements.ghostField.classList.add('hidden');
                elements.placementHint.classList.remove('active');

                document.querySelectorAll('.pdf-page-wrapper').forEach(pw => {
                    pw.classList.remove('placement-mode');
                });
            }
        }

        function handlePageClick(e, pageNum, pageWrapper) {
            // If not in placement mode, do nothing (allow dragging existing fields)
            if (!state.selectedFieldType || state.selectedFieldType === 'pointer') {
                return;
            }

            // Don't place if clicking on existing field
            if (e.target.closest('.placed-field')) {
                return;
            }

            const recipientId = parseInt(elements.currentRecipient.value);
            if (!recipientId) {
                showToast('Please select a recipient first');
                return;
            }

            const rect = pageWrapper.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            addField(state.selectedFieldType, pageNum, x, y);

            // Stay in placement mode for quick multiple placements
            // User can click pointer or press Esc to exit
        }

        function addField(type, page, x, y) {
            const recipientId = parseInt(elements.currentRecipient.value);
            if (!recipientId) {
                showToast('Please select a recipient first');
                return;
            }

            const recipient = state.recipients.find(r => r.id === recipientId);

            // Determine if field should be required (default: true for signature, user choice for others)
            const isRequired = type === 'signature' ? true : elements.fieldRequired.checked;

            const width = type === 'checkbox' ? 24 : (type === 'signature' ? 150 : 100);
            const height = type === 'checkbox' ? 24 : (type === 'signature' ? 50 : 30);

            // Bug #1: Check field bounds before placing
            const pageWrapper = elements.pdfPagesWrapper.querySelector(`[data-page="${page}"]`);
            if (pageWrapper) {
                const pageWidth = pageWrapper.offsetWidth;
                const pageHeight = pageWrapper.offsetHeight;

                // Adjust position if field would extend past page edges
                let adjustedX = x;
                let adjustedY = y;
                let wasAdjusted = false;

                if (x + width > pageWidth) {
                    adjustedX = Math.max(0, pageWidth - width);
                    wasAdjusted = true;
                }
                if (y + height > pageHeight) {
                    adjustedY = Math.max(0, pageHeight - height);
                    wasAdjusted = true;
                }
                if (x < 0) {
                    adjustedX = 0;
                    wasAdjusted = true;
                }
                if (y < 0) {
                    adjustedY = 0;
                    wasAdjusted = true;
                }

                if (wasAdjusted) {
                    showToast('Field adjusted to fit within page bounds');
                    x = adjustedX;
                    y = adjustedY;
                }
            }

            const field = {
                id: Date.now(),
                type,
                recipientId,
                page,
                x,
                y,
                width,
                height,
                value: '', // For text, date, initials fields
                checked: false, // For checkbox fields
                required: isRequired // Required vs optional
            };

            // Handle field-specific initialization
            if (type === 'text') {
                const text = prompt('Enter text for this field:', '');
                if (text === null) return; // User cancelled
                field.value = text || 'Text';
            } else if (type === 'date') {
                // Placeholder - actual date filled at signing time
                field.value = 'Date';
            } else if (type === 'initials') {
                // Auto-generate initials from recipient name
                if (recipient) {
                    const parts = recipient.name.trim().split(/\s+/);
                    field.value = parts.map(p => p[0]?.toUpperCase() || '').join('');
                } else {
                    field.value = 'XX';
                }
            } else if (type === 'checkbox') {
                field.checked = true; // Default to checked
            }

            state.placedFields.push(field);
            renderPlacedFields();
        }

        function renderPlacedFields() {
            // Remove existing field elements
            document.querySelectorAll('.placed-field').forEach(el => el.remove());

            // Render fields on their respective pages
            state.placedFields.forEach(field => {
                const pageWrapper = elements.pdfPagesWrapper.querySelector(`[data-page="${field.page}"]`);
                if (!pageWrapper) return;

                const recipient = state.recipients.find(r => r.id === field.recipientId);

                const el = document.createElement('div');
                el.className = 'placed-field';
                el.style.cssText = `left:${field.x}px;top:${field.y}px;width:${field.width}px;height:${field.height}px;--recipient-color:${recipient?.color || '#1e40af'}`;
                el.dataset.fieldId = field.id;

                // Show field value based on type
                let displayContent;
                if (field.type === 'checkbox') {
                    displayContent = field.checked ? 'â˜‘ï¸' : 'â˜';
                } else if (field.type === 'text' || field.type === 'date' || field.type === 'initials') {
                    displayContent = field.value || getFieldLabel(field.type);
                } else {
                    displayContent = getFieldLabel(field.type);
                }

                el.innerHTML = `
                    ${field.required ? '<span class="required-indicator">*</span>' : ''}
                    <span class="field-content">${displayContent}</span>
                    <button class="delete-btn" onclick="event.stopPropagation(); window.deleteField(${field.id})">Ã—</button>
                    <div class="resize-handle"></div>
                `;

                // Add click handler for checkbox toggle
                if (field.type === 'checkbox') {
                    el.addEventListener('dblclick', (e) => {
                        if (e.target.classList.contains('delete-btn')) return;
                        field.checked = !field.checked;
                        renderPlacedFields();
                    });
                }

                // Add click handler to edit text fields
                if (field.type === 'text') {
                    el.addEventListener('dblclick', (e) => {
                        if (e.target.classList.contains('delete-btn')) return;
                        const newValue = prompt('Edit text:', field.value);
                        if (newValue !== null) {
                            field.value = newValue || 'Text';
                            renderPlacedFields();
                        }
                    });
                }

                // Add right-click menu to toggle required status (except for signature fields)
                if (field.type !== 'signature') {
                    el.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        field.required = !field.required;
                        renderPlacedFields();
                        showToast(`Field marked as ${field.required ? 'required' : 'optional'}`);
                    });
                }

                makeDraggable(el, field);
                makeResizable(el, field);

                pageWrapper.appendChild(el);
            });
        }

        function getFieldLabel(type) {
            const labels = {
                signature: 'âœï¸ Signature',
                initials: 'ðŸ”¤ Initials',
                date: 'ðŸ“… Date',
                text: 'ðŸ“ Text',
                checkbox: 'â˜‘ï¸ Check'
            };
            return labels[type] || type;
        }

        window.deleteField = function(id) {
            state.placedFields = state.placedFields.filter(f => f.id !== id);
            renderPlacedFields();
        };

        function makeDraggable(el, field) {
            let isDragging = false;
            let startX, startY, initialX, initialY;

            el.addEventListener('mousedown', (e) => {
                if (e.target.classList.contains('delete-btn') || e.target.classList.contains('resize-handle')) return;
                if (state.selectedFieldType && state.selectedFieldType !== 'pointer') return; // Don't drag in placement mode

                isDragging = true;
                startX = e.clientX;
                startY = e.clientY;
                initialX = field.x;
                initialY = field.y;
                el.classList.add('selected');
                e.preventDefault();
                e.stopPropagation();
            });

            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                const dx = e.clientX - startX;
                const dy = e.clientY - startY;
                field.x = Math.max(0, initialX + dx);
                field.y = Math.max(0, initialY + dy);
                el.style.left = field.x + 'px';
                el.style.top = field.y + 'px';
            });

            document.addEventListener('mouseup', () => {
                if (isDragging) {
                    isDragging = false;
                    el.classList.remove('selected');
                }
            });
        }

        function makeResizable(el, field) {
            const handle = el.querySelector('.resize-handle');
            let isResizing = false;
            let startX, startY, initialW, initialH;

            handle.addEventListener('mousedown', (e) => {
                isResizing = true;
                startX = e.clientX;
                startY = e.clientY;
                initialW = field.width;
                initialH = field.height;
                e.stopPropagation();
            });

            document.addEventListener('mousemove', (e) => {
                if (!isResizing) return;
                const dx = e.clientX - startX;
                const dy = e.clientY - startY;
                field.width = Math.max(50, initialW + dx);
                field.height = Math.max(20, initialH + dy);
                el.style.width = field.width + 'px';
                el.style.height = field.height + 'px';
            });

            document.addEventListener('mouseup', () => {
                isResizing = false;
            });
        }

        // Update Signing Button
        function updateSigningButton() {
            const signers = state.recipients.filter(r => r.role === 'signer');

            // For SENDER flow (not remote signer): NO immediate signing allowed
            // Show only "Send for Signing" which opens modal
            if (!state.remoteSession.isRemoteSigner) {
                // Hide "Sign as X" button entirely in sender flow
                elements.btnSend.classList.add('hidden');
                // Show generate links button instead
                elements.btnGenerateLinks.classList.remove('hidden');
                elements.btnDownload.classList.add('hidden');
                return;
            }

            // For REMOTE SIGNER flow: allow immediate signing
            if (signers.length === 0) {
                elements.btnSend.classList.add('hidden');
                return;
            }

            if (state.signingStatus.currentSignerIndex >= signers.length) {
                // All done
                elements.btnSend.classList.add('hidden');
                elements.btnDownload.classList.remove('hidden');
            } else {
                // Bug fix: Button should just say "Sign", not "Sign as X"
                elements.btnSend.innerHTML = 'Sign';
                elements.btnSend.classList.remove('hidden');
                elements.btnDownload.classList.add('hidden');
            }
        }

        // Review (Step 4)
        const REVIEW_SCALE = 1.5; // Scale for review preview (matches editor scale)

        async function renderReview() {
            // Update signing button text
            updateSigningButton();
            // Summary
            elements.summaryDocName.textContent = state.fileName;
            elements.summaryPages.textContent = state.totalPages;
            elements.summaryRecipients.textContent = state.recipients.length;
            elements.summaryFields.textContent = state.placedFields.length;

            // Expiration display
            const expirationCard = document.getElementById('expiration-card');
            const expirationSelect = document.getElementById('expiration-select');
            const expirationInfo = document.getElementById('expiration-info');
            const expirationDeadline = document.getElementById('expiration-deadline');

            if (state.remoteSession.isRemoteSigner && state.remoteSession.expiresAt) {
                // Hide select, show expiration info for remote signers
                if (expirationSelect) expirationSelect.style.display = 'none';
                if (expirationInfo) {
                    expirationInfo.classList.remove('hidden');
                    const expiresAt = new Date(state.remoteSession.expiresAt);
                    const now = new Date();
                    const hoursLeft = Math.max(0, Math.round((expiresAt - now) / (1000 * 60 * 60)));
                    const daysLeft = Math.floor(hoursLeft / 24);
                    const timeLeft = daysLeft > 0 ? `${daysLeft} days` : `${hoursLeft} hours`;
                    expirationDeadline.textContent = `${expiresAt.toLocaleString()} (${timeLeft} remaining)`;

                    // Change color if expiring soon (with proper text contrast)
                    if (hoursLeft < 24) {
                        expirationInfo.style.background = '#fee2e2'; // Red background
                        expirationInfo.style.color = '#991b1b'; // Dark red text for contrast
                    } else if (hoursLeft < 72) {
                        expirationInfo.style.background = '#fef3c7'; // Yellow background
                        expirationInfo.style.color = '#92400e'; // Dark amber text for contrast
                    } else {
                        expirationInfo.style.background = '#fef3c7'; // Yellow background (default)
                        expirationInfo.style.color = '#92400e'; // Dark amber text for contrast
                    }
                }
            } else {
                // Show select for document sender
                if (expirationSelect) expirationSelect.style.display = '';
                if (expirationInfo) expirationInfo.classList.add('hidden');
            }

            // Hide audit log and LTV card for sender flow (not needed for dispatch)
            const auditPanel = document.querySelector('.audit-panel');
            const ltvCard = document.getElementById('ltv-timestamp-card');
            if (!state.remoteSession.isRemoteSigner) {
                if (auditPanel) auditPanel.style.display = 'none';
                if (ltvCard) ltvCard.style.display = 'none';
            } else {
                // Show for remote signers
                if (auditPanel) auditPanel.style.display = '';
                if (ltvCard) ltvCard.style.display = '';
            }

            // Recipients with field navigation (modern DocuSign-style)
            const signers = state.recipients.filter(r => r.role === 'signer');
            elements.reviewRecipients.innerHTML = state.recipients.map((r, index) => {
                // Get fields for this recipient
                const recipientFields = state.placedFields.filter(f => f.recipientId === r.id);
                const fieldCount = recipientFields.length;

                // Status badge only for remote signer flow
                let statusBadge = '';
                if (state.remoteSession.isRemoteSigner && r.role === 'signer') {
                    const signerIndex = signers.findIndex(s => s.id === r.id);
                    if (state.signingStatus.completedSigners.includes(r.id)) {
                        statusBadge = '<span style="padding:0.125rem 0.5rem;background:#10b981;color:white;border-radius:4px;font-size:0.625rem;font-weight:600;">SIGNED</span>';
                    } else if (signerIndex === state.signingStatus.currentSignerIndex) {
                        statusBadge = '<span style="padding:0.125rem 0.5rem;background:#f59e0b;color:white;border-radius:4px;font-size:0.625rem;font-weight:600;">CURRENT</span>';
                    } else {
                        statusBadge = '<span style="padding:0.125rem 0.5rem;background:#9ca3af;color:white;border-radius:4px;font-size:0.625rem;font-weight:600;">PENDING</span>';
                    }
                }

                // Build clickable field list for sender flow
                let fieldListHtml = '';
                if (!state.remoteSession.isRemoteSigner && fieldCount > 0) {
                    fieldListHtml = `
                        <div class="recipient-field-list" style="margin-top: 0.5rem; padding-left: 1rem; border-left: 2px solid ${r.color};">
                            ${recipientFields.map((field, fieldIndex) => {
                                const icon = getFieldIcon(field.type);
                                const typeName = field.type.charAt(0).toUpperCase() + field.type.slice(1);
                                return `
                                    <button
                                        type="button"
                                        onclick="scrollToField('${field.id}')"
                                        class="field-nav-btn"
                                        style="
                                            display: flex;
                                            align-items: center;
                                            gap: 0.5rem;
                                            width: 100%;
                                            padding: 0.375rem 0.5rem;
                                            margin: 0.25rem 0;
                                            background: transparent;
                                            border: 1px solid #e5e7eb;
                                            border-radius: 4px;
                                            font-size: 0.8125rem;
                                            cursor: pointer;
                                            text-align: left;
                                            transition: background 0.2s, border-color 0.2s;
                                        "
                                        onmouseover="this.style.background='#f3f4f6';this.style.borderColor='${r.color}';"
                                        onmouseout="this.style.background='transparent';this.style.borderColor='#e5e7eb';"
                                    >
                                        <span style="font-size: 1rem;">${icon}</span>
                                        <span>${typeName}</span>
                                        <span style="margin-left: auto; color: #9ca3af; font-size: 0.75rem;">Page ${field.page}</span>
                                    </button>
                                `;
                            }).join('')}
                        </div>
                    `;
                }

                return `
                    <div class="recipient-card" style="margin-bottom: 0.75rem; padding-bottom: 0.75rem; border-bottom: 1px solid #f3f4f6;">
                        <div class="summary-item" style="margin-bottom: 0;">
                            <span class="summary-label" style="display:flex;align-items:center;gap:0.5rem;">
                                <span style="width:10px;height:10px;background:${r.color};border-radius:50%;"></span>
                                <span style="font-weight: 500;">${r.name}</span>
                                ${fieldCount > 0 ? `<span style="background:#e5e7eb;color:#374151;padding:0.125rem 0.5rem;border-radius:10px;font-size:0.75rem;">${fieldCount} field${fieldCount !== 1 ? 's' : ''}</span>` : ''}
                            </span>
                            <span class="summary-value" style="display:flex;align-items:center;gap:0.5rem;">
                                ${statusBadge || (r.role === 'signer' ? 'Signer' : 'CC')}
                            </span>
                        </div>
                        ${fieldListHtml}
                    </div>
                `;
            }).join('');

            // Audit log
            updateAuditLog();

            // Render all pages with field overlays
            elements.reviewPdfBody.innerHTML = '';

            for (let pageNum = 1; pageNum <= state.totalPages; pageNum++) {
                const page = await state.pdfDoc.getPage(pageNum);
                const viewport = page.getViewport({ scale: REVIEW_SCALE });

                // Create page container for relative positioning
                const pageContainer = document.createElement('div');
                pageContainer.className = 'review-page-container';
                pageContainer.style.cssText = `
                    position: relative;
                    width: ${viewport.width}px;
                    height: ${viewport.height}px;
                    margin: 0 auto 1rem;
                    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
                    background: white;
                `;
                pageContainer.dataset.page = pageNum;

                // Create and render canvas
                const canvas = document.createElement('canvas');
                canvas.width = viewport.width;
                canvas.height = viewport.height;
                canvas.style.display = 'block';

                await page.render({
                    canvasContext: canvas.getContext('2d'),
                    viewport
                }).promise;

                pageContainer.appendChild(canvas);

                // Add field overlays for this page
                const pageFields = state.placedFields.filter(f => f.page === pageNum);
                const scaleRatio = REVIEW_SCALE / state.scale; // Convert from editor scale to review scale

                pageFields.forEach(field => {
                    const recipient = state.recipients.find(r => r.id === field.recipientId);
                    const fieldOverlay = document.createElement('div');

                    // Scale field position and size
                    const scaledX = field.x * scaleRatio;
                    const scaledY = field.y * scaleRatio;
                    const scaledWidth = field.width * scaleRatio;
                    const scaledHeight = field.height * scaleRatio;

                    fieldOverlay.className = 'review-field-overlay';
                    fieldOverlay.dataset.fieldId = field.id;
                    fieldOverlay.dataset.fieldType = field.type;
                    fieldOverlay.dataset.recipientId = field.recipientId;

                    // Bug fix: All fields should be editable for remote signers (not just signature)
                    const signers = state.recipients.filter(r => r.role === 'signer');
                    const currentSigner = signers[state.signingStatus.currentSignerIndex];
                    const isCurrentSignerField = currentSigner && field.recipientId === currentSigner.id;
                    const isAlreadySigned = state.signingStatus.completedSigners.includes(field.recipientId);
                    const isSignatureField = field.type === 'signature';
                    const isEditableField = field.type === 'text' || field.type === 'date' || field.type === 'initials' || field.type === 'checkbox';

                    // Signature fields are clickable if unsigned
                    // Other editable fields are always clickable for current signer
                    const isSignatureClickable = state.remoteSession.isRemoteSigner && isSignatureField && isCurrentSignerField && !isAlreadySigned && !field.signatureData;
                    const isOtherFieldClickable = state.remoteSession.isRemoteSigner && isEditableField && isCurrentSignerField;
                    const isClickable = isSignatureClickable || isOtherFieldClickable;

                    // Determine display content based on field type and value
                    let displayContent;
                    const icon = getFieldIcon(field.type);
                    const recipientName = recipient ? recipient.name.split(' ')[0] : 'Signer';

                    if (field.signatureData) {
                        // Show signature image if signed
                        displayContent = `<img src="${field.signatureData}" style="max-width: 90%; max-height: 90%; object-fit: contain;" alt="Signature">`;
                    } else if (field.value && (field.type === 'text' || field.type === 'date' || field.type === 'initials')) {
                        // Show entered value
                        displayContent = `<span style="font-size: ${Math.max(10, scaledHeight * 0.35)}px; color: #000;">${field.value}</span>`;
                    } else if (field.type === 'checkbox') {
                        displayContent = field.checked
                            ? `<span style="font-size: ${Math.max(16, scaledHeight * 0.6)}px;">â˜‘ï¸</span>`
                            : `<span style="font-size: ${Math.max(16, scaledHeight * 0.6)}px;">â˜</span>`;
                    } else {
                        // Default: show icon and recipient name
                        displayContent = `
                            <span style="font-size: ${Math.max(12, scaledHeight * 0.4)}px;">${icon}</span>
                            <span style="font-size: ${Math.max(8, scaledHeight * 0.25)}px; opacity: 0.8; margin-top: 2px;">${recipientName}</span>
                        `;
                    }

                    fieldOverlay.style.cssText = `
                        position: absolute;
                        left: ${scaledX}px;
                        top: ${scaledY}px;
                        width: ${scaledWidth}px;
                        height: ${scaledHeight}px;
                        border: 2px solid ${recipient?.color || '#1e40af'};
                        background: ${field.signatureData || field.value || field.checked ? 'white' : (recipient?.color || '#1e40af') + '15'};
                        border-radius: 4px;
                        display: flex;
                        flex-direction: column;
                        align-items: center;
                        justify-content: center;
                        font-size: ${Math.max(9, scaledHeight * 0.3)}px;
                        color: ${recipient?.color || '#1e40af'};
                        font-weight: 500;
                        pointer-events: ${isClickable ? 'auto' : 'none'};
                        cursor: ${isClickable ? 'pointer' : 'default'};
                        box-sizing: border-box;
                        overflow: hidden;
                        transition: transform 0.1s, box-shadow 0.1s;
                    `;

                    fieldOverlay.innerHTML = displayContent;

                    // Add click handlers based on field type
                    if (isSignatureClickable) {
                        fieldOverlay.addEventListener('click', () => handleSignatureFieldClick(field));
                    } else if (isOtherFieldClickable) {
                        fieldOverlay.addEventListener('click', () => handleEditableFieldClick(field, fieldOverlay));
                    }

                    // Add hover effect for clickable fields
                    if (isClickable) {
                        fieldOverlay.addEventListener('mouseenter', () => {
                            fieldOverlay.style.transform = 'scale(1.02)';
                            fieldOverlay.style.boxShadow = '0 4px 12px rgba(0,0,0,0.15)';
                        });
                        fieldOverlay.addEventListener('mouseleave', () => {
                            fieldOverlay.style.transform = 'scale(1)';
                            fieldOverlay.style.boxShadow = 'none';
                        });
                    }

                    pageContainer.appendChild(fieldOverlay);
                });

                elements.reviewPdfBody.appendChild(pageContainer);
            }

            // Bug #12: Setup editable page input (MUST be before updateReviewUI so _updateDisplay exists)
            const reviewPageIndicator = document.getElementById('review-page-indicator');
            if (reviewPageIndicator && !reviewPageIndicator.dataset.editableSetup) {
                setupEditablePageInput(
                    reviewPageIndicator,
                    reviewState,
                    scrollToReviewPage,
                    () => state.totalPages
                );
            }

            // Bug #10 fix: Reset to page 1 and update UI after render completes
            // NOTE: Must be AFTER setupEditablePageInput so _updateDisplay function exists
            reviewState.currentPage = 1;
            updateReviewUI();

            // Bug #11: Add floating scroll navigation buttons
            setupScrollNavButtons(elements.reviewPdfBody, 'review');

            // Bug #13: Add Ctrl+scroll zoom for desktop
            setupCtrlScrollZoom(elements.reviewPdfBody, reviewState, renderReview);
        }

        function getFieldIcon(type) {
            const icons = {
                signature: 'âœï¸',
                initials: 'ðŸ”¤',
                date: 'ðŸ“…',
                text: 'ðŸ“',
                checkbox: 'â˜‘ï¸'
            };
            return icons[type] || 'ðŸ“Œ';
        }

        // Field navigation - scroll to field and highlight
        window.scrollToField = function(fieldId) {
            // Find the field overlay by data-field-id
            const targetOverlay = document.querySelector(`.review-field-overlay[data-field-id="${fieldId}"]`);
            if (!targetOverlay) return;

            // Find the page container and scroll to it
            const pageContainer = targetOverlay.closest('.review-page-container');
            if (pageContainer) {
                // Scroll to bring the field into view
                targetOverlay.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }

            // Highlight the field briefly
            highlightFieldOverlay(targetOverlay);
        };

        function highlightFieldOverlay(overlay) {
            // Store original styles
            const originalBorder = overlay.style.border;
            const originalBoxShadow = overlay.style.boxShadow;
            const originalTransform = overlay.style.transform;

            // Apply highlight
            overlay.style.border = '3px solid #fbbf24';
            overlay.style.boxShadow = '0 0 20px rgba(251, 191, 36, 0.6)';
            overlay.style.transform = 'scale(1.05)';
            overlay.style.transition = 'all 0.3s ease';
            overlay.style.zIndex = '10';

            // Remove highlight after delay
            setTimeout(() => {
                overlay.style.border = originalBorder;
                overlay.style.boxShadow = originalBoxShadow || 'none';
                overlay.style.transform = originalTransform || 'none';
                overlay.style.zIndex = '';
            }, 1500);
        }

        function updateAuditLog() {
            if (!state.docSign) {
                elements.auditLog.innerHTML = '<div class="audit-entry"><span class="audit-event">No activity yet</span></div>';
                elements.auditVerification.innerHTML = '';
                return;
            }

            try {
                const summary = state.docSign.get_audit_summary();
                if (!summary || summary.length === 0) {
                    elements.auditLog.innerHTML = '<div class="audit-entry"><span class="audit-event">No activity yet</span></div>';
                    elements.auditVerification.innerHTML = '';
                    return;
                }

                elements.auditLog.innerHTML = summary.map(entry => {
                    // entry is a string like "[date] email - ACTION"
                    return `<div class="audit-entry"><span class="audit-event">${entry}</span></div>`;
                }).join('');

                // Verify audit chain integrity
                try {
                    const isValid = state.docSign.verify_audit_chain();
                    if (isValid) {
                        elements.auditVerification.innerHTML = '<span style="color: #22c55e;">âœ“ Verified</span>';
                        elements.auditVerification.title = 'Audit chain integrity verified - no tampering detected';
                    } else {
                        elements.auditVerification.innerHTML = '<span style="color: #ef4444;">âš  Invalid</span>';
                        elements.auditVerification.title = 'Audit chain verification failed - possible tampering';
                    }
                } catch (verifyErr) {
                    console.error('Audit verification error:', verifyErr);
                    elements.auditVerification.innerHTML = '<span style="color: #f59e0b;">? Unknown</span>';
                    elements.auditVerification.title = 'Could not verify audit chain';
                }
            } catch (err) {
                console.error('Audit log error:', err);
                elements.auditLog.innerHTML = '<div class="audit-entry"><span class="audit-event">-</span></div>';
                elements.auditVerification.innerHTML = '';
            }
        }

        // Validate Required Fields
        function validateRequiredFields() {
            const missingFields = [];

            state.placedFields.forEach(field => {
                if (!field.required) return; // Skip optional fields

                // Check if field has a value based on its type
                let isEmpty = false;

                if (field.type === 'signature' || field.type === 'initials') {
                    // Signature and initials are considered "empty" until signed
                    // We'll allow them to be processed during signing
                    isEmpty = false;
                } else if (field.type === 'text') {
                    isEmpty = !field.value || field.value.trim() === '';
                } else if (field.type === 'date') {
                    isEmpty = !field.value || field.value.trim() === '';
                } else if (field.type === 'checkbox') {
                    // Checkboxes are always considered filled (they have a checked state)
                    isEmpty = false;
                }

                if (isEmpty) {
                    const recipient = state.recipients.find(r => r.id === field.recipientId);
                    missingFields.push({
                        type: field.type,
                        recipientName: recipient ? recipient.name : 'Unknown',
                        page: field.page
                    });
                }
            });

            return missingFields;
        }

        // Send for Signing - Async with Web Worker for large PDFs
        async function sendForSigning() {
            const signers = state.recipients.filter(r => r.role === 'signer');
            if (signers.length === 0) {
                showToast('No signers added');
                return;
            }

            if (state.signingStatus.currentSignerIndex >= signers.length) {
                showToast('All signers have completed signing');
                return;
            }

            const currentSigner = signers[state.signingStatus.currentSignerIndex];
            const signatureFields = state.placedFields.filter(f => f.type === 'signature' && f.recipientId === currentSigner.id);

            if (signatureFields.length === 0) {
                showToast(`No signature fields for ${currentSigner.name}`);
                return;
            }

            // Show consent modal for remote signers (REQUIRED before signing)
            if (state.remoteSession.isRemoteSigner && !state.remoteSession.hasConsented) {
                const consented = await showConsentModal();
                if (!consented) {
                    return; // User declined
                }
                state.remoteSession.hasConsented = true;
            }

            // For REMOTE SIGNERS: Use signature modal instead of auto-signing
            // This allows them to draw or type their actual signature
            if (state.remoteSession.isRemoteSigner) {
                // Find the first unsigned field for the current signer
                const unsignedField = signatureFields.find(f => !f.signatureData);
                if (unsignedField) {
                    // Open signature modal for this field
                    handleSignatureFieldClick(unsignedField);
                } else {
                    showToast('All signature fields have been signed!');
                }
                return;
            }

            try {
                elements.loadingOverlay.classList.remove('hidden');
                updateSigningProgress('Preparing document...', 5);

                // Helper: Convert DOM coords to PDF coords
                function domToPdfCoords(field) {
                    const pageDims = state.pageDimensions[field.page];
                    if (!pageDims) return null;

                    const pdfWidth = pageDims.width;
                    const pdfHeight = pageDims.height;
                    const canvasWidth = pageDims.canvasWidth || (pdfWidth * state.scale);
                    const canvasHeight = pageDims.canvasHeight || (pdfHeight * state.scale);
                    const scaleX = pdfWidth / canvasWidth;
                    const scaleY = pdfHeight / canvasHeight;

                    return {
                        x: field.x * scaleX,
                        y: pdfHeight - (field.y + field.height) * scaleY,
                        width: field.width * scaleX,
                        height: field.height * scaleY
                    };
                }

                // Use Web Worker if available, otherwise fall back to main thread
                const useWorker = !!signingWorker;

                // On first signature, add all non-signature fields
                if (state.signingStatus.currentSignerIndex === 0) {
                    const nonSigFields = state.placedFields.filter(f =>
                        f.type === 'date' || f.type === 'text' || f.type === 'initials' || f.type === 'checkbox'
                    );

                    updateSigningProgress('Adding form fields...', 15);
                    let fieldCount = 0;
                    for (const field of nonSigFields) {
                        const coords = domToPdfCoords(field);
                        if (!coords) continue;

                        try {
                            // For date fields, fill in current date at signing time
                            const fieldValue = field.type === 'date'
                                ? new Date().toLocaleDateString()
                                : (field.value || '');

                            if (useWorker) {
                                if (field.type === 'checkbox') {
                                    await signingWorker.addCheckbox(field.page, coords.x, coords.y,
                                        Math.min(coords.width, coords.height), field.checked);
                                } else {
                                    await signingWorker.addTextField(field.page, coords.x, coords.y,
                                        coords.width, coords.height, fieldValue, field.type);
                                }
                            } else {
                                // Main thread fallback
                                if (field.type === 'checkbox') {
                                    state.docSign.add_checkbox_field(field.page, coords.x, coords.y,
                                        Math.min(coords.width, coords.height), field.checked);
                                } else {
                                    state.docSign.add_text_field(field.page, coords.x, coords.y,
                                        coords.width, coords.height, fieldValue, field.type);
                                }
                            }
                            fieldCount++;
                            updateSigningProgress(`Adding fields (${fieldCount}/${nonSigFields.length})...`, 15 + (fieldCount / nonSigFields.length) * 15);
                        } catch (fieldErr) {
                            console.error(`Failed to add ${field.type} field:`, fieldErr);
                        }
                        // Yield to UI thread periodically
                        if (fieldCount % 5 === 0) await new Promise(r => setTimeout(r, 0));
                    }
                }

                // Sign for current signer
                if (!useWorker) {
                    state.docSign.set_signer_email(currentSigner.email);
                }
                updateSigningProgress('Signing document...', 40);

                let sigCount = 0;
                for (const field of signatureFields) {
                    const coords = domToPdfCoords(field);
                    if (!coords) continue;

                    updateSigningProgress(`Signing field ${sigCount + 1}/${signatureFields.length}...`, 40 + (sigCount / signatureFields.length) * 50);

                    try {
                        // Yield before heavy operation
                        await new Promise(r => setTimeout(r, 10));

                        if (useWorker) {
                            await signingWorker.signField(field.page, coords.x, coords.y,
                                coords.width, coords.height, `Signed by ${currentSigner.name}`, currentSigner.email);
                        } else {
                            state.docSign.sign_document(field.page, coords.x, coords.y,
                                coords.width, coords.height, `Signed by ${currentSigner.name}`);
                        }
                        sigCount++;
                    } catch (signErr) {
                        console.error('Sign error:', signErr);
                        throw new Error(`Failed to sign field on page ${field.page}: ${signErr.message || signErr}`);
                    }
                }

                // Mark current signer as completed
                state.signingStatus.completedSigners.push(currentSigner.id);

                // Move to next signer
                state.signingStatus.currentSignerIndex++;

                showToast(`${currentSigner.name} signed successfully!`);

                // Check if all signers are done
                if (state.signingStatus.currentSignerIndex >= signers.length) {
                    // All done - show download button
                    elements.btnSend.classList.add('hidden');
                    elements.btnDownload.classList.remove('hidden');

                    // If remote signer, submit back to server
                    if (state.remoteSession.isRemoteSigner) {
                        await submitSignedDocument();
                        showToast('Signing complete! Document submitted.');
                    } else {
                        showToast('All signers have completed! Document ready for download.');
                    }
                } else {
                    // Update button for next signer
                    updateSigningButton();

                    // If remote signer, submit after each signature
                    if (state.remoteSession.isRemoteSigner) {
                        await submitSignedDocument();
                    }
                }

                // Update UI
                updateSigningProgress('Complete!', 100);
                updateAuditLog();
                renderReview();

                // Clean up progress and hide overlay
                const progressEl = elements.loadingOverlay.querySelector('.signing-progress');
                if (progressEl) progressEl.remove();
                elements.loadingOverlay.classList.add('hidden');

            } catch (err) {
                console.error('Signing failed:', err);
                const progressEl = elements.loadingOverlay.querySelector('.signing-progress');
                if (progressEl) progressEl.remove();
                elements.loadingOverlay.classList.add('hidden');
                showToast(getPdfErrorMessage(err.message || err));
            }
        }

        // Settings
        function openSettings() {
            updateCertificateDisplay();
            // Populate profile fields from current user
            const user = window.DocSign?.getCurrentUser?.();
            if (user) {
                document.getElementById('profile-first-name').value = user.first_name || '';
                document.getElementById('profile-middle-initial').value = user.middle_initial || '';
                document.getElementById('profile-last-name').value = user.last_name || '';
                // Update plan & usage display (Bug #6.3)
                updatePlanUsage(user);
            }
            // Hide any previous status
            const statusEl = document.getElementById('profile-status');
            if (statusEl) statusEl.style.display = 'none';
            document.getElementById('settings-modal').classList.remove('hidden');
        }

        // closeSettingsModal already defined above - removed duplicate

        // Plan & Usage functions (Bug #6.3)
        function updatePlanUsage(user) {
            if (!user) return;

            // Map tier to display info
            const tierColors = {
                'Free': { bg: '#e6f0ff', text: '#0056b3' },
                'Personal': { bg: '#ecfdf5', text: '#059669' },
                'Professional': { bg: '#fef3c7', text: '#d97706' },
                'Business': { bg: '#f3e8ff', text: '#7c3aed' },
                'Pro': { bg: '#ecfdf5', text: '#059669' }  // Legacy
            };

            const tierLimits = {
                'Free': 3,
                'Personal': 25,
                'Professional': 100,
                'Business': 300,
                'Pro': 25  // Legacy
            };

            const tierName = user.tier || 'Free';
            const limit = tierLimits[tierName] || 3;
            const used = user.monthly_document_count || 0;
            const percentage = Math.min(100, Math.round((used / limit) * 100));
            const colors = tierColors[tierName] || tierColors['Free'];

            // Update badge
            const badge = document.getElementById('plan-tier-badge');
            if (badge) {
                badge.textContent = tierName;
                badge.style.background = colors.bg;
                badge.style.color = colors.text;
            }

            // Update billing cycle
            const cycleEl = document.getElementById('plan-billing-cycle');
            if (cycleEl) {
                const cycle = user.billing_cycle;
                cycleEl.textContent = (cycle && cycle !== 'Monthly') ? `(${cycle})` : '';
            }

            // Update usage text
            const usageText = document.getElementById('plan-usage-text');
            if (usageText) {
                usageText.textContent = `${used} / ${limit}`;
            }

            // Update usage bar
            const usageBar = document.getElementById('plan-usage-bar');
            if (usageBar) {
                usageBar.style.width = `${percentage}%`;
                // Change color when at limit
                if (percentage >= 100) {
                    usageBar.style.background = '#dc2626';
                } else if (percentage >= 80) {
                    usageBar.style.background = '#d97706';
                } else {
                    usageBar.style.background = '#0056b3';
                }
            }

            // Update overage info (for paid tiers only)
            const overageInfo = document.getElementById('plan-overage-info');
            const overageText = document.getElementById('plan-overage-text');
            if (overageInfo && overageText) {
                const overage = user.overage_count || 0;
                if (overage > 0 && tierName !== 'Free') {
                    overageInfo.style.display = 'block';
                    overageText.textContent = `${overage} overage document${overage !== 1 ? 's' : ''} ($${(overage * 0.5).toFixed(2)})`;
                } else {
                    overageInfo.style.display = 'none';
                }
            }
        }

        function showLimitModal(user) {
            const modal = document.getElementById('limit-modal');
            if (!modal) return;

            const tierName = user?.tier || 'Free';
            const limit = { 'Free': 3, 'Personal': 25, 'Professional': 100, 'Business': 300, 'Pro': 25 }[tierName] || 3;

            // Update message with tier-specific info
            const messageEl = document.getElementById('limit-message');
            if (messageEl) {
                messageEl.textContent = `You've used all ${limit} documents available on your ${tierName} plan this month.`;
            }

            // Calculate reset date (1st of next month)
            const resetEl = document.getElementById('limit-reset-info');
            if (resetEl) {
                const now = new Date();
                const nextMonth = new Date(now.getFullYear(), now.getMonth() + 1, 1);
                const monthName = nextMonth.toLocaleString('default', { month: 'long' });
                resetEl.textContent = `Your limit resets on ${monthName} 1st.`;
            }

            modal.classList.remove('hidden');
        }

        function closeLimitModal() {
            const modal = document.getElementById('limit-modal');
            if (modal) {
                modal.classList.add('hidden');
            }
        }
        window.closeLimitModal = closeLimitModal;

        // Bug #4: Feedback modal functions
        function openFeedbackModal() {
            const modal = document.getElementById('feedback-modal');
            if (modal) {
                // Reset form
                document.getElementById('feedback-type').value = 'bug';
                document.getElementById('feedback-description').value = '';
                document.getElementById('docs-request-section').classList.add('hidden');
                document.getElementById('feedback-status').classList.add('hidden');
                document.getElementById('btn-submit-feedback').disabled = false;
                document.getElementById('btn-submit-feedback').textContent = 'Submit Feedback';
                modal.classList.remove('hidden');
            }
        }
        window.openFeedbackModal = openFeedbackModal;

        function closeFeedbackModal() {
            const modal = document.getElementById('feedback-modal');
            if (modal) {
                modal.classList.add('hidden');
            }
        }
        window.closeFeedbackModal = closeFeedbackModal;

        // Show/hide docs request section based on type
        document.addEventListener('DOMContentLoaded', function() {
            const feedbackType = document.getElementById('feedback-type');
            if (feedbackType) {
                feedbackType.addEventListener('change', function() {
                    const docsSection = document.getElementById('docs-request-section');
                    if (this.value === 'more_documents') {
                        docsSection.classList.remove('hidden');
                    } else {
                        docsSection.classList.add('hidden');
                    }
                });
            }
        });

        async function submitFeedback() {
            const btn = document.getElementById('btn-submit-feedback');
            const statusEl = document.getElementById('feedback-status');
            const typeEl = document.getElementById('feedback-type');
            const descEl = document.getElementById('feedback-description');
            const docsEl = document.getElementById('additional-docs');

            const requestType = typeEl.value;
            const description = descEl.value.trim();
            const additionalDocs = requestType === 'more_documents' ? parseInt(docsEl.value) : null;

            if (!description) {
                statusEl.textContent = 'Please provide a description.';
                statusEl.style.background = '#fef2f2';
                statusEl.style.color = '#dc2626';
                statusEl.classList.remove('hidden');
                return;
            }

            if (description.length > 2000) {
                statusEl.textContent = 'Description too long (max 2000 characters).';
                statusEl.style.background = '#fef2f2';
                statusEl.style.color = '#dc2626';
                statusEl.classList.remove('hidden');
                return;
            }

            btn.disabled = true;
            btn.textContent = 'Submitting...';
            statusEl.classList.add('hidden');

            try {
                const response = await window.DocSign.authenticatedFetch('https://api.getsignatures.org/requests/submit', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        request_type: requestType,
                        description: description,
                        additional_documents: additionalDocs
                    })
                });

                const result = await response.json();

                if (result.success) {
                    statusEl.textContent = result.message || 'Thank you for your feedback!';
                    statusEl.style.background = '#ecfdf5';
                    statusEl.style.color = '#059669';
                    statusEl.classList.remove('hidden');
                    // Close modal after 2 seconds
                    setTimeout(() => {
                        closeFeedbackModal();
                    }, 2000);
                } else {
                    statusEl.textContent = result.message || 'Failed to submit feedback. Please try again.';
                    statusEl.style.background = '#fef2f2';
                    statusEl.style.color = '#dc2626';
                    statusEl.classList.remove('hidden');
                    btn.disabled = false;
                    btn.textContent = 'Submit Feedback';
                }
            } catch (error) {
                console.error('Failed to submit feedback:', error);
                statusEl.textContent = 'Failed to submit feedback. Please try again.';
                statusEl.style.background = '#fef2f2';
                statusEl.style.color = '#dc2626';
                statusEl.classList.remove('hidden');
                btn.disabled = false;
                btn.textContent = 'Submit Feedback';
            }
        }
        window.submitFeedback = submitFeedback;

        // Save profile changes
        async function saveProfile() {
            const btn = document.getElementById('btn-save-profile');
            const statusEl = document.getElementById('profile-status');
            const firstName = document.getElementById('profile-first-name').value.trim();
            const middleInitial = document.getElementById('profile-middle-initial').value.trim().toUpperCase();
            const lastName = document.getElementById('profile-last-name').value.trim();

            if (!firstName || !lastName) {
                statusEl.textContent = 'First and last name are required.';
                statusEl.style.color = '#b30000';
                statusEl.style.display = 'block';
                return;
            }

            btn.disabled = true;
            btn.textContent = 'Saving...';

            try {
                const result = await window.DocSign.updateProfile({
                    first_name: firstName,
                    middle_initial: middleInitial || undefined,
                    last_name: lastName,
                });

                if (result.success) {
                    statusEl.textContent = 'Profile saved!';
                    statusEl.style.color = '#006644';
                    // Update header greeting
                    const greetingEl = document.getElementById('user-email');
                    if (greetingEl) greetingEl.textContent = `Welcome back, ${firstName}`;
                } else {
                    statusEl.textContent = result.message || 'Failed to save profile.';
                    statusEl.style.color = '#b30000';
                }
                statusEl.style.display = 'block';
            } catch (error) {
                statusEl.textContent = 'Could not save profile. Please try again.';
                statusEl.style.color = '#b30000';
                statusEl.style.display = 'block';
            } finally {
                btn.disabled = false;
                btn.textContent = 'Save Profile';
            }
        }
        window.saveProfile = saveProfile;

        // Consent Modal for Remote Signers
        let consentResolve = null;

        function showConsentModal() {
            return new Promise((resolve) => {
                consentResolve = resolve;

                // Update document name
                const docNameEl = document.getElementById('consent-doc-name');
                if (docNameEl) docNameEl.textContent = state.fileName || 'Document';

                // Reset checkbox
                const checkbox = document.getElementById('consent-checkbox');
                const agreeBtn = document.getElementById('consent-agree-btn');
                if (checkbox) {
                    checkbox.checked = false;
                    checkbox.onchange = () => {
                        agreeBtn.disabled = !checkbox.checked;
                    };
                }
                if (agreeBtn) agreeBtn.disabled = true;

                // Show modal
                document.getElementById('consent-modal').classList.remove('hidden');
            });
        }

        function closeConsentModal() {
            document.getElementById('consent-modal').classList.add('hidden');
            consentResolve = null;
        }

        window.declineConsent = function() {
            // CRITICAL: Save resolver BEFORE closeConsentModal() nullifies it
            const resolver = consentResolve;
            closeConsentModal();
            if (resolver) {
                resolver(false);
            }
            showToast('You declined to sign. Please contact the document sender if you have questions.');
        };

        window.acceptConsent = function() {
            // CRITICAL: Save resolver BEFORE closeConsentModal() nullifies it
            // Without this, the Promise never resolves and hasConsented is never set
            const resolver = consentResolve;
            closeConsentModal();
            if (resolver) {
                resolver(true);
            }
        };

        // ============================================================
        // Signature Modal for capturing drawn/typed signatures
        // ============================================================

        let signatureModalResolve = null;
        let currentSignatureField = null;
        let signaturePadInstance = null;
        let typedSignatureInstance = null;

        /**
         * Handle click on a signature field in review mode
         * Shows consent modal if needed, then signature capture modal
         */
        async function handleSignatureFieldClick(field) {
            // Check if consent is needed first
            if (state.remoteSession.isRemoteSigner && !state.remoteSession.hasConsented) {
                const consented = await showConsentModal();
                if (!consented) {
                    return; // User declined
                }
                state.remoteSession.hasConsented = true;
            }

            // Show signature capture modal
            currentSignatureField = field;
            showSignatureModal(field);
        }

        /**
         * Show the signature capture modal
         */
        function showSignatureModal(field) {
            const modal = document.getElementById('signature-capture-modal');
            if (!modal) {
                console.error('Signature modal not found');
                return;
            }

            // Get signer name for pre-filling typed signature
            const signers = state.recipients.filter(r => r.role === 'signer');
            const currentSigner = signers[state.signingStatus.currentSignerIndex];
            const signerName = currentSigner?.name || '';

            // Pre-fill typed name input
            const typedNameInput = document.getElementById('sig-typed-name');
            if (typedNameInput) {
                typedNameInput.value = signerName;
                updateTypedSignaturePreview();
            }

            // Initialize signature pad if needed
            const canvas = document.getElementById('sig-draw-canvas');
            if (canvas && !signaturePadInstance) {
                initializeSignaturePad(canvas);
            }

            // Clear any previous signature
            if (signaturePadInstance) {
                signaturePadInstance.clear();
            }

            // Default to type mode (more accessible for elderly users)
            switchSignatureTab('type');

            // Show modal
            modal.classList.remove('hidden');
        }

        /**
         * Initialize the signature drawing pad
         */
        function initializeSignaturePad(canvas) {
            const ctx = canvas.getContext('2d');

            // Set canvas size based on container
            const rect = canvas.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);

            // Drawing state
            let isDrawing = false;
            let lastX = 0;
            let lastY = 0;
            let hasDrawn = false;

            // Style
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 2;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            function getPos(e) {
                const rect = canvas.getBoundingClientRect();
                const x = (e.clientX || e.touches?.[0]?.clientX) - rect.left;
                const y = (e.clientY || e.touches?.[0]?.clientY) - rect.top;
                return { x, y };
            }

            function startDraw(e) {
                e.preventDefault();
                isDrawing = true;
                const pos = getPos(e);
                lastX = pos.x;
                lastY = pos.y;
            }

            function draw(e) {
                if (!isDrawing) return;
                e.preventDefault();
                const pos = getPos(e);
                ctx.beginPath();
                ctx.moveTo(lastX, lastY);
                ctx.lineTo(pos.x, pos.y);
                ctx.stroke();
                lastX = pos.x;
                lastY = pos.y;
                hasDrawn = true;
            }

            function endDraw() {
                isDrawing = false;
            }

            // Mouse events
            canvas.addEventListener('mousedown', startDraw);
            canvas.addEventListener('mousemove', draw);
            canvas.addEventListener('mouseup', endDraw);
            canvas.addEventListener('mouseleave', endDraw);

            // Touch events
            canvas.addEventListener('touchstart', startDraw);
            canvas.addEventListener('touchmove', draw);
            canvas.addEventListener('touchend', endDraw);

            signaturePadInstance = {
                clear: () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    hasDrawn = false;
                },
                isEmpty: () => !hasDrawn,
                toDataURL: () => canvas.toDataURL('image/png'),
            };
        }

        /**
         * Switch between draw and type tabs in signature modal
         */
        function switchSignatureTab(tab) {
            const drawTab = document.getElementById('sig-tab-draw');
            const typeTab = document.getElementById('sig-tab-type');
            const drawPanel = document.getElementById('sig-draw-panel');
            const typePanel = document.getElementById('sig-type-panel');

            if (tab === 'draw') {
                drawTab?.classList.add('active');
                typeTab?.classList.remove('active');
                drawPanel?.classList.remove('hidden');
                typePanel?.classList.add('hidden');

                // CRITICAL: Re-initialize canvas AFTER panel is visible
                // getBoundingClientRect() returns 0x0 for hidden elements (per MDN)
                // Must re-init each time to get correct dimensions
                const canvas = document.getElementById('sig-draw-canvas');
                if (canvas) {
                    // Use requestAnimationFrame to ensure DOM has updated
                    requestAnimationFrame(() => {
                        initializeSignaturePad(canvas);
                    });
                }
            } else {
                typeTab?.classList.add('active');
                drawTab?.classList.remove('active');
                typePanel?.classList.remove('hidden');
                drawPanel?.classList.add('hidden');
            }
        }

        /**
         * Update the typed signature preview
         */
        function updateTypedSignaturePreview() {
            const input = document.getElementById('sig-typed-name');
            const preview = document.getElementById('sig-typed-preview');
            const fontSelect = document.getElementById('sig-font-select');

            if (!input || !preview) return;

            const text = input.value || '';
            const font = fontSelect?.value || 'Dancing Script';

            preview.style.fontFamily = `'${font}', cursive`;
            preview.textContent = text;
        }

        /**
         * Close signature modal (cancel)
         */
        function closeSignatureModal() {
            const modal = document.getElementById('signature-capture-modal');
            if (modal) {
                modal.classList.add('hidden');
            }
            currentSignatureField = null;
        }

        /**
         * Apply the signature from modal to the field
         */
        async function applySignature() {
            if (!currentSignatureField) {
                showToast('No signature field selected');
                return;
            }

            // Determine which mode is active
            const typePanel = document.getElementById('sig-type-panel');
            const isTypeMode = typePanel && !typePanel.classList.contains('hidden');

            let signatureDataUrl;

            if (isTypeMode) {
                // Generate typed signature image
                const input = document.getElementById('sig-typed-name');
                const fontSelect = document.getElementById('sig-font-select');
                const text = input?.value?.trim() || '';

                if (!text) {
                    showToast('Please enter your name');
                    return;
                }

                const font = fontSelect?.value || 'Dancing Script';
                signatureDataUrl = generateTypedSignatureImage(text, font);
            } else {
                // Get drawn signature
                if (!signaturePadInstance || signaturePadInstance.isEmpty()) {
                    showToast('Please draw your signature');
                    return;
                }
                signatureDataUrl = signaturePadInstance.toDataURL();
            }

            // CRITICAL: Save field reference BEFORE closeSignatureModal() clears it
            const field = currentSignatureField;

            // Close modal (this sets currentSignatureField = null)
            closeSignatureModal();

            // Apply signature to field using saved reference
            await applySignatureToField(field, signatureDataUrl);
        }

        /**
         * Handle click on editable fields (text, date, initials, checkbox)
         */
        async function handleEditableFieldClick(field, overlay) {
            // Check if consent is needed first (same as signature fields)
            if (state.remoteSession.isRemoteSigner && !state.remoteSession.hasConsented) {
                const consented = await showConsentModal();
                if (!consented) {
                    return;
                }
                state.remoteSession.hasConsented = true;
            }

            if (field.type === 'checkbox') {
                // Toggle checkbox
                field.checked = !field.checked;
                showToast(field.checked ? 'Checkbox checked' : 'Checkbox unchecked');
                await renderReview(); // Re-render to show updated state
                return;
            }

            if (field.type === 'date') {
                // Auto-fill with current date
                const today = new Date();
                const dateStr = today.toLocaleDateString('en-US', {
                    year: 'numeric',
                    month: '2-digit',
                    day: '2-digit'
                });

                // Allow user to edit or accept default
                const newValue = prompt('Enter date:', field.value || dateStr);
                if (newValue !== null && newValue.trim()) {
                    field.value = newValue.trim();
                    showToast('Date entered');
                    await renderReview();
                }
                return;
            }

            if (field.type === 'text') {
                // Get signer name for default
                const signers = state.recipients.filter(r => r.role === 'signer');
                const currentSigner = signers[state.signingStatus.currentSignerIndex];
                const defaultValue = field.value || currentSigner?.name || '';

                const newValue = prompt('Enter text:', defaultValue);
                if (newValue !== null && newValue.trim()) {
                    field.value = newValue.trim();
                    showToast('Text entered');
                    await renderReview();
                }
                return;
            }

            if (field.type === 'initials') {
                // Get initials from signer name
                const signers = state.recipients.filter(r => r.role === 'signer');
                const currentSigner = signers[state.signingStatus.currentSignerIndex];
                const defaultInitials = currentSigner?.name
                    ? currentSigner.name.split(' ').map(n => n[0]).join('').toUpperCase()
                    : '';

                const newValue = prompt('Enter initials:', field.value || defaultInitials);
                if (newValue !== null && newValue.trim()) {
                    field.value = newValue.trim().toUpperCase();
                    showToast('Initials entered');
                    await renderReview();
                }
                return;
            }
        }

        /**
         * Generate an image from typed text with cursive font
         */
        function generateTypedSignatureImage(text, fontFamily) {
            const canvas = document.createElement('canvas');
            canvas.width = 400;
            canvas.height = 100;
            const ctx = canvas.getContext('2d');

            // Clear
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw text
            ctx.font = `48px '${fontFamily}', cursive`;
            ctx.fillStyle = '#000000';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, canvas.width / 2, canvas.height / 2);

            return canvas.toDataURL('image/png');
        }

        /**
         * Embed signature image into PDF using pdf-lib.js
         * This replaces the WASM sign_document() which only added text, not images
         */
        async function embedSignatureImage(pdfBytes, signatureDataUrl, pageNum, x, y, width, height) {
            const { PDFDocument } = PDFLib;

            // Load existing PDF
            const pdfDoc = await PDFDocument.load(pdfBytes);

            // Get the page (0-indexed in pdf-lib)
            const page = pdfDoc.getPage(pageNum - 1);

            // Embed the signature PNG (strip data URL prefix)
            const pngData = signatureDataUrl.replace(/^data:image\/png;base64,/, '');
            const pngBytes = Uint8Array.from(atob(pngData), c => c.charCodeAt(0));
            const pngImage = await pdfDoc.embedPng(pngBytes);

            // Draw signature at coordinates
            // PDF coords have (0,0) at bottom-left, which domToPdfCoords already handles
            page.drawImage(pngImage, {
                x: x,
                y: y,
                width: width,
                height: height,
            });

            // Save modified PDF
            return await pdfDoc.save();
        }

        /**
         * Apply signature image to a field and embed it in the PDF
         */
        async function applySignatureToField(field, signatureDataUrl) {
            try {
                elements.loadingOverlay.classList.remove('hidden');
                showToast('Applying signature...');

                const signers = state.recipients.filter(r => r.role === 'signer');
                const currentSigner = signers[state.signingStatus.currentSignerIndex];

                // Convert DOM coords to PDF coords
                function domToPdfCoords(field) {
                    const pageDims = state.pageDimensions[field.page];
                    if (!pageDims) return null;

                    const pdfWidth = pageDims.width;
                    const pdfHeight = pageDims.height;
                    const canvasWidth = pageDims.canvasWidth || (pdfWidth * state.scale);
                    const canvasHeight = pageDims.canvasHeight || (pdfHeight * state.scale);
                    const scaleX = pdfWidth / canvasWidth;
                    const scaleY = pdfHeight / canvasHeight;

                    return {
                        x: field.x * scaleX,
                        y: pdfHeight - (field.y + field.height) * scaleY,
                        width: field.width * scaleX,
                        height: field.height * scaleY
                    };
                }

                const coords = domToPdfCoords(field);
                if (!coords) {
                    throw new Error('Could not calculate field coordinates');
                }

                // Get current PDF bytes from WASM or state
                let currentPdfBytes;
                if (state.docSign) {
                    const bytesResult = state.docSign.get_document_bytes();
                    currentPdfBytes = new Uint8Array(bytesResult);
                } else {
                    currentPdfBytes = state.pdfBytes;
                }

                // Embed signature image using pdf-lib (replaces old WASM sign_document)
                console.log('[Signing] Embedding signature at:', coords);
                const newPdfBytes = await embedSignatureImage(
                    currentPdfBytes,
                    signatureDataUrl,
                    field.page,
                    coords.x,
                    coords.y,
                    coords.width,
                    coords.height
                );

                // Update the document in WASM/state
                if (state.docSign) {
                    state.docSign.load_pdf(new Uint8Array(newPdfBytes));
                }
                state.pdfBytes = new Uint8Array(newPdfBytes);

                // Mark field as signed (store signature data for visual update)
                field.signatureData = signatureDataUrl;

                // Check if all signature fields for current signer are done
                const signerFields = state.placedFields.filter(
                    f => f.type === 'signature' && f.recipientId === currentSigner.id
                );
                const allSigned = signerFields.every(f => f.signatureData);

                if (allSigned) {
                    // Mark current signer as completed
                    state.signingStatus.completedSigners.push(currentSigner.id);
                    state.signingStatus.currentSignerIndex++;

                    // Check if all signers are done
                    if (state.signingStatus.currentSignerIndex >= signers.length) {
                        // All done
                        elements.btnSend.classList.add('hidden');
                        elements.btnDownload.classList.remove('hidden');

                        if (state.remoteSession.isRemoteSigner) {
                            await submitSignedDocument();
                            showToast('All signatures complete! Document submitted.');
                        } else {
                            showToast('All signatures complete! Ready for download.');
                        }
                    } else {
                        updateSigningButton();
                        showToast(`${currentSigner.name} signature complete!`);
                    }
                } else {
                    showToast('Signature applied! Click remaining fields to sign.');
                }

                // Refresh review to show signed state
                updateAuditLog();
                await renderReview();

                elements.loadingOverlay.classList.add('hidden');

            } catch (err) {
                console.error('Signature application failed:', err);
                elements.loadingOverlay.classList.add('hidden');
                showToast('Failed to apply signature: ' + (err.message || err));
            }
        }

        // Expose functions for onclick handlers
        window.switchSignatureTab = switchSignatureTab;
        window.closeSignatureModal = closeSignatureModal;
        window.applySignature = applySignature;
        window.updateTypedSignaturePreview = updateTypedSignaturePreview;
        window.clearSignaturePad = function() {
            if (signaturePadInstance) {
                signaturePadInstance.clear();
            }
        };

        async function importCertificate() {
            const certFileInput = document.getElementById('cert-file-input');
            const keyFileInput = document.getElementById('key-file-input');
            if (!certFileInput.files[0] || !keyFileInput.files[0]) {
                showToast('Please select both certificate and private key files');
                return;
            }
            try {
                const certFile = certFileInput.files[0];
                const certPem = await certFile.text();
                const keyFile = keyFileInput.files[0];
                const keyPem = await keyFile.text();
                if (!state.docSign) {
                    showToast('DocSign not initialized');
                    return;
                }
                state.docSign.import_certificate(certPem, keyPem);
                updateCertificateDisplay();
                updateCertificateIndicator();
                showToast('Certificate imported successfully');
                certFileInput.value = '';
                keyFileInput.value = '';
            } catch (err) {
                console.error('Certificate import failed:', err);
                showToast('Certificate import failed: ' + (err.message || String(err)));
            }
        }

        function clearCertificate() {
            if (!state.docSign) return;
            if (confirm('Are you sure you want to clear the current certificate?')) {
                state.docSign.clear_certificate();
                updateCertificateDisplay();
                updateCertificateIndicator();
                showToast('Certificate cleared');
            }
        }

        function updateCertificateDisplay() {
            if (!state.docSign) return;
            const hasCert = state.docSign.has_certificate();
            const certInfoContainer = document.getElementById('cert-info-container');
            const certInfoDisplay = document.getElementById('cert-info-display');
            if (hasCert) {
                try {
                    const info = state.docSign.get_certificate_info();
                    const validityClass = info.isValid ? 'cert-valid' : 'cert-invalid';
                    const validityText = info.isValid ? 'Valid' : 'Invalid';
                    certInfoDisplay.innerHTML = `
                        <div class="cert-info-row">
                            <span class="cert-info-label">Subject</span>
                            <span class="cert-info-value">${escapeHtml(info.subject)}</span>
                        </div>
                        <div class="cert-info-row">
                            <span class="cert-info-label">Issuer</span>
                            <span class="cert-info-value">${escapeHtml(info.issuer)}</span>
                        </div>
                        <div class="cert-info-row">
                            <span class="cert-info-label">Serial Number</span>
                            <span class="cert-info-value">${escapeHtml(info.serialNumber)}</span>
                        </div>
                        <div class="cert-info-row">
                            <span class="cert-info-label">Valid From</span>
                            <span class="cert-info-value">${escapeHtml(info.notBefore)}</span>
                        </div>
                        <div class="cert-info-row">
                            <span class="cert-info-label">Valid Until</span>
                            <span class="cert-info-value">${escapeHtml(info.notAfter)}</span>
                        </div>
                        <div class="cert-info-row">
                            <span class="cert-info-label">Status</span>
                            <span class="cert-info-value ${validityClass}">${validityText}</span>
                        </div>
                    `;
                    certInfoContainer.classList.remove('hidden');
                } catch (err) {
                    console.error('Failed to get certificate info:', err);
                    certInfoContainer.classList.add('hidden');
                }
            } else {
                certInfoContainer.classList.add('hidden');
            }
        }

        function updateCertificateIndicator() {
            if (!state.docSign) return;
            const indicator = document.getElementById('cert-status-indicator');
            const hasCert = state.docSign.has_certificate();
            if (hasCert) {
                indicator.classList.remove('hidden');
            } else {
                indicator.classList.add('hidden');
            }
        }

        /**
         * SOTA base64 encoding for Uint8Array (Bug #14 fix)
         * Uses native toBase64() if available (Sept 2025+), falls back to iterative loop.
         * NEVER use btoa(String.fromCharCode(...array)) - causes stack overflow on large files!
         */
        function uint8ArrayToBase64(bytes) {
            // Use native method if available (Sept 2025+)
            if (typeof bytes.toBase64 === 'function') {
                return bytes.toBase64();
            }
            // Fallback: iterative loop (safe for any size, no stack overflow)
            let binary = '';
            for (let i = 0; i < bytes.length; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return btoa(binary);
        }

        /**
         * SOTA base64 decoding to Uint8Array (Bug #14 fix)
         * Uses native fromBase64() if available (Sept 2025+), falls back to iterative loop.
         */
        function base64ToUint8Array(base64) {
            // Use native method if available (Sept 2025+)
            if (typeof Uint8Array.fromBase64 === 'function') {
                return Uint8Array.fromBase64(base64);
            }
            // Fallback: iterative decode
            const binary = atob(base64);
            const bytes = new Uint8Array(binary.length);
            for (let i = 0; i < binary.length; i++) {
                bytes[i] = binary.charCodeAt(i);
            }
            return bytes;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text || '';
            return div.innerHTML;
        }

        // Email sending via Cloudflare Worker
        async function sendEmailsToRecipients(serverUrl, recipients) {
            if (!state.docSign) return;

            try {
                const pdfBytes = state.docSign.get_document_bytes();
                const pdfBase64 = uint8ArrayToBase64(new Uint8Array(pdfBytes));
                const filename = state.fileName.replace('.pdf', '_signed.pdf');

                let successCount = 0;
                let failCount = 0;

                for (const recipient of recipients) {
                    try {
                        const response = await fetch(`${serverUrl}/send`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                to: recipient.email,
                                subject: `Document for Signature: ${state.fileName}`,
                                pdf_base64: pdfBase64,
                                filename: filename
                            })
                        });

                        const result = await response.json();

                        if (result.success) {
                            successCount++;
                            console.log(`Email sent to ${recipient.email}. Remaining: ${result.remaining_today}/day, ${result.remaining_month}/month`);
                        } else {
                            failCount++;
                            console.error(`Failed to send to ${recipient.email}: ${result.message}`);
                        }
                    } catch (emailErr) {
                        failCount++;
                        console.error(`Failed to send to ${recipient.email}:`, emailErr);
                    }
                }

                if (successCount > 0 && failCount === 0) {
                    showToast(`Sent to ${successCount} recipient(s)`);
                } else if (successCount > 0) {
                    showToast(`Sent to ${successCount}, failed ${failCount}`);
                } else {
                    showToast('Failed to send emails');
                }
            } catch (err) {
                console.error('Email sending failed:', err);
                showToast('Failed to send emails: ' + (err.message || err));
            }
        }

        async function downloadPDF() {
            if (!signingWorker && !state.docSign) {
                showToast('No signed document available');
                return;
            }

            try {
                elements.loadingOverlay.classList.remove('hidden');
                updateSigningProgress('Preparing download...', 50);

                let bytes;
                if (signingWorker) {
                    const pdfBuffer = await signingWorker.getPdf();
                    bytes = new Uint8Array(pdfBuffer);
                } else {
                    bytes = state.docSign.get_document_bytes();
                }

                const blob = new Blob([bytes], { type: 'application/pdf' });
                const url = URL.createObjectURL(blob);

                const a = document.createElement('a');
                a.href = url;
                a.download = state.fileName.replace('.pdf', '_signed.pdf');
                a.click();

                URL.revokeObjectURL(url);
                elements.loadingOverlay.classList.add('hidden');
                showToast('Download started');
            } catch (err) {
                console.error('Download failed:', err);
                elements.loadingOverlay.classList.add('hidden');
                showToast('Download failed: ' + (err.message || err));
            }
        }

        // Draft Management
        async function saveDraft() {
            if (!state.storage) {
                showToast('Local storage unavailable. Cannot save drafts in private/incognito mode.');
                return;
            }
            if (!state.pdfBytes) {
                showToast('No document loaded. Upload a PDF first.');
                return;
            }

            try {
                const documentId = state.docSign?.document_id() || `draft_${Date.now()}`;

                // Serialize state (only serializable parts)
                const draftState = {
                    currentStep: state.currentStep,
                    fileName: state.fileName,
                    recipients: state.recipients,
                    placedFields: state.placedFields,
                    currentPage: state.currentPage,
                    totalPages: state.totalPages,
                    pageDimensions: state.pageDimensions,
                    savedAt: new Date().toISOString()
                };

                // Store the PDF bytes
                await state.storage.store_document(documentId, state.pdfBytes, state.fileName);

                // Store the draft state
                await state.storage.store_draft(documentId, JSON.stringify(draftState));

                // Remember the draft ID for later
                localStorage.setItem('lastDraftId', documentId);

                showToast('Draft saved');
            } catch (err) {
                console.error('Save draft failed:', err);
                showToast(getPdfErrorMessage(err.message || err));
            }
        }

        async function loadDraft(draftId) {
            if (!state.storage) return false;

            try {
                elements.loadingOverlay.classList.remove('hidden');

                // Load draft state
                const draftJson = await state.storage.get_draft(draftId);
                if (!draftJson) {
                    elements.loadingOverlay.classList.add('hidden');
                    return false;
                }
                const draft = JSON.parse(draftJson);

                // Load PDF bytes (get_document returns the Uint8Array directly)
                const docData = await state.storage.get_document(draftId);
                if (!docData || docData.length === 0) {
                    elements.loadingOverlay.classList.add('hidden');
                    return false;
                }

                // Restore state
                state.pdfBytes = new Uint8Array(docData);
                state.fileName = draft.fileName;
                state.recipients = draft.recipients || [];
                state.placedFields = draft.placedFields || [];
                state.currentPage = draft.currentPage || 1;
                state.pageDimensions = draft.pageDimensions || {};

                // Re-initialize PDF
                state.pdfDoc = await pdfjsLib.getDocument({ data: state.pdfBytes }).promise;
                state.totalPages = state.pdfDoc.numPages;

                // Re-initialize WASM
                state.docSign = new DocSign();
                await state.docSign.load_pdf(state.pdfBytes);

                // Update certificate indicator
                updateCertificateIndicator();

                // Go to saved step
                goToStep(draft.currentStep || 2);

                elements.loadingOverlay.classList.add('hidden');
                showToast('Draft loaded');
                return true;
            } catch (err) {
                console.error('Load draft failed:', err);
                elements.loadingOverlay.classList.add('hidden');
                showToast('Could not load draft');
                return false;
            }
        }

        async function checkForDrafts() {
            const lastDraftId = localStorage.getItem('lastDraftId');
            if (!lastDraftId || !state.storage) return;

            try {
                const draftJson = await state.storage.get_draft(lastDraftId);
                if (draftJson) {
                    const draft = JSON.parse(draftJson);
                    const savedAt = new Date(draft.savedAt).toLocaleString();

                    if (confirm(`Found a saved draft from ${savedAt}.\n\nFile: ${draft.fileName}\nRecipients: ${draft.recipients?.length || 0}\n\nWould you like to continue where you left off?`)) {
                        await loadDraft(lastDraftId);
                    } else {
                        // Clear the draft reference if user declines
                        localStorage.removeItem('lastDraftId');
                    }
                }
            } catch (err) {
                console.error('Check drafts failed:', err);
            }
        }

        // Template Management
        async function saveTemplateAs() {
            if (state.placedFields.length === 0) {
                showToast('No fields to save as template');
                return;
            }

            document.getElementById('save-template-modal').classList.remove('hidden');
            document.getElementById('template-name-input').value = '';
            document.getElementById('template-name-input').focus();
        }

        function closeSaveTemplateModal() {
            document.getElementById('save-template-modal').classList.add('hidden');
        }

        async function saveTemplate() {
            const name = document.getElementById('template-name-input').value.trim();
            if (!name) {
                showToast('Please enter a template name');
                return;
            }

            try {
                // Convert placed fields to API format (percentage-based with snake_case)
                const templateFields = state.placedFields.map(field => {
                    const pageDims = state.pageDimensions[field.page];
                    const canvasWidth = pageDims?.canvasWidth || 800;
                    const canvasHeight = pageDims?.canvasHeight || 1000;

                    // Find recipient index (0-based)
                    const recipientIndex = state.recipients.findIndex(r => r.id === field.recipientId);

                    return {
                        field_type: field.type,
                        recipient_index: recipientIndex >= 0 ? recipientIndex : 0,
                        page: field.page,
                        x_percent: (field.x / canvasWidth) * 100,
                        y_percent: (field.y / canvasHeight) * 100,
                        width_percent: (field.width / canvasWidth) * 100,
                        height_percent: (field.height / canvasHeight) * 100,
                        required: field.required || false
                    };
                });

                // Check if user is authenticated
                if (!window.DocSign || !window.DocSign.authenticatedFetch) {
                    showToast('Please sign in to save templates');
                    return;
                }

                const response = await window.DocSign.authenticatedFetch(`${SIGNING_SERVER_URL}/templates`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name, fields: templateFields })
                });

                if (!response.ok) {
                    const error = await response.json().catch(() => ({}));
                    throw new Error(error.message || 'Failed to save template');
                }

                const result = await response.json();

                closeSaveTemplateModal();
                showToast(`Template "${name}" saved`);
            } catch (err) {
                console.error('Failed to save template:', err);
                showToast('Failed to save template: ' + (err.message || err));
            }
        }

        async function loadTemplateModal() {
            document.getElementById('load-template-modal').classList.remove('hidden');
            await renderTemplateList();
        }

        function closeLoadTemplateModal() {
            document.getElementById('load-template-modal').classList.add('hidden');
        }

        async function renderTemplateList() {
            const templateList = document.getElementById('template-list');

            // Check if user is authenticated
            if (!window.DocSign?.authenticatedFetch) {
                templateList.innerHTML = '<div class="empty-state">Sign in to use templates</div>';
                return;
            }

            try {
                templateList.innerHTML = '<div class="loading-state">Loading templates...</div>';

                const response = await window.DocSign.authenticatedFetch(`${SIGNING_SERVER_URL}/templates`);
                if (!response.ok) {
                    throw new Error('Failed to fetch templates');
                }

                const data = await response.json();
                const templates = data.templates || [];

                if (templates.length === 0) {
                    templateList.innerHTML = '<div class="empty-state">No templates saved yet</div>';
                    return;
                }

                const templateItems = templates.map(template => {
                    const createdDate = new Date(template.created_at).toLocaleDateString();
                    return `
                        <li class="template-item" data-template-id="${template.id}">
                            <div class="template-info">
                                <div class="template-name">${template.name}</div>
                                <div class="template-meta">${template.field_count} fields &bull; ${createdDate}</div>
                            </div>
                            <div class="template-actions">
                                <button class="btn-preview" onclick="previewTemplate('${template.id}')">Preview</button>
                                <button class="btn-load" onclick="loadTemplate('${template.id}')">Load</button>
                                <button class="btn-delete" onclick="deleteTemplate('${template.id}')">Delete</button>
                            </div>
                            <div class="template-preview-content hidden" id="template-preview-${template.id}"></div>
                        </li>
                    `;
                });

                templateList.innerHTML = templateItems.join('');
            } catch (err) {
                console.error('Error loading templates:', err);
                templateList.innerHTML = '<div class="empty-state error">Failed to load templates</div>';
            }
        }

        async function loadTemplate(templateId) {
            try {
                // Check if user is authenticated
                if (!window.DocSign?.authenticatedFetch) {
                    showToast('Sign in to use templates');
                    return;
                }

                // Fetch template from API
                const response = await window.DocSign.authenticatedFetch(`${SIGNING_SERVER_URL}/templates/${templateId}`);
                if (!response.ok) {
                    if (response.status === 404) {
                        showToast('Template not found');
                    } else {
                        showToast('Failed to load template');
                    }
                    return;
                }

                const data = await response.json();
                const template = data.template;

                if (!template.fields || template.fields.length === 0) {
                    showToast('Template has no fields');
                    return;
                }

                // Check if there's a current recipient selected
                const recipientId = parseInt(elements.currentRecipient.value);
                if (!recipientId) {
                    showToast('Please select a recipient first');
                    return;
                }

                // Convert percentage-based positions back to absolute positions
                // API uses snake_case field names
                const newFields = template.fields.map(tmplField => {
                    const pageDims = state.pageDimensions[tmplField.page];
                    if (!pageDims) {
                        console.warn(`No dimensions for page ${tmplField.page}`);
                        return null;
                    }

                    const canvasWidth = pageDims.canvasWidth || 800;
                    const canvasHeight = pageDims.canvasHeight || 1000;

                    return {
                        id: Date.now() + Math.random(),
                        type: tmplField.field_type,
                        recipientId,
                        page: tmplField.page,
                        x: (tmplField.x_percent / 100) * canvasWidth,
                        y: (tmplField.y_percent / 100) * canvasHeight,
                        width: (tmplField.width_percent / 100) * canvasWidth,
                        height: (tmplField.height_percent / 100) * canvasHeight,
                        value: '',
                        checked: false,
                        required: tmplField.required !== undefined ? tmplField.required : true
                    };
                }).filter(f => f !== null);

                // Add fields to state
                state.placedFields.push(...newFields);
                renderPlacedFields();

                closeLoadTemplateModal();
                showToast(`Loaded ${newFields.length} fields from template`);
            } catch (err) {
                console.error('Failed to load template:', err);
                showToast('Failed to load template: ' + (err.message || err));
            }
        }

        async function deleteTemplate(templateId) {
            if (!confirm('Are you sure you want to delete this template?')) {
                return;
            }

            try {
                // Check if user is authenticated
                if (!window.DocSign?.authenticatedFetch) {
                    showToast('Sign in to manage templates');
                    return;
                }

                // Delete via API
                const response = await window.DocSign.authenticatedFetch(`${SIGNING_SERVER_URL}/templates/${templateId}`, {
                    method: 'DELETE'
                });

                if (!response.ok) {
                    if (response.status === 404) {
                        showToast('Template not found');
                    } else {
                        showToast('Failed to delete template');
                    }
                    return;
                }

                showToast('Template deleted');
                await renderTemplateList();
            } catch (err) {
                console.error('Failed to delete template:', err);
                showToast('Failed to delete template');
            }
        }

        async function previewTemplate(templateId) {
            const previewEl = document.getElementById(`template-preview-${templateId}`);
            if (!previewEl) return;

            // Toggle visibility - if already showing, hide it
            if (!previewEl.classList.contains('hidden')) {
                previewEl.classList.add('hidden');
                return;
            }

            // Check if user is authenticated
            if (!window.DocSign?.authenticatedFetch) {
                showToast('Sign in to preview templates');
                return;
            }

            try {
                previewEl.innerHTML = '<div class="loading-state">Loading preview...</div>';
                previewEl.classList.remove('hidden');

                // Fetch template details from API
                const response = await window.DocSign.authenticatedFetch(`${SIGNING_SERVER_URL}/templates/${templateId}`);
                if (!response.ok) {
                    throw new Error('Failed to fetch template');
                }

                const data = await response.json();
                const template = data.template;

                if (!template.fields || template.fields.length === 0) {
                    previewEl.innerHTML = '<div class="preview-empty">No fields in this template</div>';
                    return;
                }

                // Group fields by type and page
                const fieldsByType = {};
                const fieldsByPage = {};
                template.fields.forEach(field => {
                    // Count by type
                    const type = field.field_type || 'unknown';
                    fieldsByType[type] = (fieldsByType[type] || 0) + 1;

                    // Count by page
                    const page = field.page || 1;
                    fieldsByPage[page] = (fieldsByPage[page] || 0) + 1;
                });

                // Build summary HTML
                const typeLabels = {
                    signature: 'Signature',
                    initials: 'Initials',
                    date: 'Date',
                    text: 'Text',
                    checkbox: 'Checkbox',
                    name: 'Name',
                    email: 'Email'
                };

                const typeSummary = Object.entries(fieldsByType)
                    .map(([type, count]) => `<span class="field-type-badge">${typeLabels[type] || type}: ${count}</span>`)
                    .join(' ');

                const pageSummary = Object.entries(fieldsByPage)
                    .sort((a, b) => parseInt(a[0]) - parseInt(b[0]))
                    .map(([page, count]) => `Page ${page}: ${count} field${count > 1 ? 's' : ''}`)
                    .join(', ');

                previewEl.innerHTML = `
                    <div class="template-preview-summary">
                        <div class="preview-section">
                            <strong>Field Types:</strong> ${typeSummary}
                        </div>
                        <div class="preview-section">
                            <strong>Distribution:</strong> ${pageSummary}
                        </div>
                        <div class="preview-section">
                            <strong>Total:</strong> ${template.fields.length} fields across ${Object.keys(fieldsByPage).length} page${Object.keys(fieldsByPage).length > 1 ? 's' : ''}
                        </div>
                    </div>
                `;
            } catch (err) {
                console.error('Failed to preview template:', err);
                previewEl.innerHTML = '<div class="preview-error">Failed to load preview</div>';
            }
        }

        // Expose template functions to window for onclick handlers
        window.closeSaveTemplateModal = closeSaveTemplateModal;
        window.saveTemplate = saveTemplate;
        window.closeLoadTemplateModal = closeLoadTemplateModal;
        window.loadTemplate = loadTemplate;
        window.deleteTemplate = deleteTemplate;
        window.previewTemplate = previewTemplate;

        // Signing Links Generation
        async function generateSigningLinks() {
            if (!state.pdfBytes || state.recipients.length === 0) {
                showToast('Please upload a PDF and add recipients first');
                return;
            }

            const signers = state.recipients.filter(r => r.role === 'signer');
            if (signers.length === 0) {
                showToast('No signers to generate links for');
                return;
            }

            const linksList = document.getElementById('signing-links-list');
            const errorDiv = document.getElementById('signing-links-error');
            const rateLimitDiv = document.getElementById('signing-links-rate-limit');
            const sendBtn = document.getElementById('btn-send-emails');
            const modalTitle = document.getElementById('signing-links-title');

            // Reset modal state
            linksList.innerHTML = '<p style="text-align: center; color: #6b7280;">Preparing signing session...</p>';
            errorDiv.classList.add('hidden');
            if (rateLimitDiv) rateLimitDiv.classList.add('hidden');
            if (sendBtn) sendBtn.classList.remove('hidden');
            if (modalTitle) modalTitle.textContent = 'Ready to Send';
            document.getElementById('signing-links-modal').classList.remove('hidden');

            try {
                // TODO: Re-enable encryption once basic signing flow is verified working
                // Bug #14 fix: Use SOTA base64 encoding (native toBase64 or iterative fallback)
                // NEVER use btoa(String.fromCharCode(...)) - causes stack overflow on large PDFs!
                // Use pdfBytesForWorker which is a copy made before PDF.js detaches the buffer
                const pdfBytesToEncode = state.pdfBytesForWorker || state.pdfBytes;
                const documentBase64 = uint8ArrayToBase64(pdfBytesToEncode);

                // Get expiration hours from selector
                const expiryHours = parseInt(document.getElementById('expiration-select')?.value || '168');

                // Prepare session data for server
                // Feature 1: Get document alias and context from modal inputs
                const documentAlias = document.getElementById('document-alias')?.value?.trim() || null;
                const signingContext = document.getElementById('signing-context')?.value?.trim() || null;

                const sessionRequest = {
                    encrypted_document: documentBase64,  // Not actually encrypted - just base64
                    metadata: {
                        filename: state.fileName || 'document.pdf',
                        page_count: state.totalPages || 1,
                        created_at: new Date().toISOString(),
                        created_by: 'Anonymous', // Could be from user settings
                        document_alias: documentAlias,
                        signing_context: signingContext
                    },
                    recipients: state.recipients.map(r => ({
                        id: r.id.toString(),
                        name: r.name,
                        email: r.email,
                        role: r.role,
                        signed: false,
                        signed_at: null
                    })),
                    fields: state.placedFields.map(f => {
                        // Use canvas dimensions for pixel-to-percent conversion
                        // Fields placed locally have x/y in canvas pixels (scaled by state.scale)
                        const pageDims = state.pageDimensions[f.page] || {};
                        const canvasW = pageDims.canvasWidth || (612 * state.scale);
                        const canvasH = pageDims.canvasHeight || (792 * state.scale);

                        return {
                            id: String(f.id),
                            field_type: f.type,
                            recipient_id: String(f.recipientId),
                            page: f.page,
                            x_percent: f.xPercent || (f.x / canvasW) * 100,
                            y_percent: f.yPercent || (f.y / canvasH) * 100,
                            width_percent: f.widthPercent || (f.width / canvasW) * 100,
                            height_percent: f.heightPercent || (f.height / canvasH) * 100,
                            required: f.required !== false,
                            value: f.value || null
                        };
                    }),
                    expiry_hours: expiryHours
                };

                // Call worker to create session (with authentication)
                const response = await window.DocSign.authenticatedFetch(`${SIGNING_SERVER_URL}/session`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(sessionRequest)
                });

                // Handle 429 (rate limit / monthly limit exceeded)
                if (response.status === 429) {
                    const errorData = await response.json().catch(() => ({}));
                    if (errorData.error_code === 'MONTHLY_LIMIT_EXCEEDED') {
                        // Show the soft-block limit modal (Bug #6.3)
                        const user = window.DocSign?.getCurrentUser?.() || { tier: errorData.tier || 'Free' };
                        showLimitModal(user);
                        closeSigningLinksModal();
                        return;
                    }
                    throw new Error(errorData.message || 'Rate limit exceeded. Please try again later.');
                }

                // Handle 413 (Payload Too Large) - PDF exceeds backend limit
                if (response.status === 413) {
                    const errorData = await response.json().catch(() => ({}));
                    const sizeMB = state.pdfData ? (state.pdfData.length * 0.75 / (1024 * 1024)).toFixed(1) : 'unknown';
                    console.error('PDF too large:', { sizeMB, maxSize: MAX_PDF_SIZE_MB });

                    // Show a helpful error with compression suggestions
                    const errorMsg = `This PDF (${sizeMB}MB) exceeds the ${MAX_PDF_SIZE_MB}MB limit.\n\nTry compressing it with:\nâ€¢ SmallPDF.com\nâ€¢ Adobe Acrobat (Reduce File Size)\nâ€¢ iLovePDF.com`;
                    throw new Error(errorMsg);
                }

                // Bug #0: Better error handling - parse JSON for error details
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    const errorCode = errorData.error_code || '';
                    const errorMsg = errorData.message || `Server error: ${response.status}`;
                    console.error('Session creation failed:', { status: response.status, errorCode, errorMsg, debugInfo: errorData.debug_info });
                    throw new Error(`[${errorCode}] ${errorMsg}`);
                }

                const sessionResult = await response.json();
                if (!sessionResult.success) {
                    const errorCode = sessionResult.error_code || '';
                    const errorMsg = sessionResult.message || 'Failed to create session';
                    console.error('Session creation failed:', { errorCode, errorMsg });
                    throw new Error(`[${errorCode}] ${errorMsg}`);
                }

                const sessionId = sessionResult.session_id;

                // Generate signing links for each signer (no encryption key in URL)
                const baseUrl = window.location.origin + window.location.pathname;
                const links = signers.map(signer => ({
                    name: signer.name,
                    email: signer.email,
                    recipientId: signer.id,
                    link: `${baseUrl}#sign=${sessionId}:${signer.id}`,  // No key - not encrypted
                    sessionId
                }));

                // Store session info in state for email sending
                state.currentSessionId = sessionId;
                state.signingLinks = links;

                // TEST_MODE: Show actual links with copy buttons for testing
                // Bug #15: In production mode, display recipients WITHOUT showing actual links (links only sent via email)
                if (TEST_MODE) {
                    // Update modal title to indicate test mode
                    if (modalTitle) modalTitle.textContent = 'ðŸ§ª Test Mode - Links Generated';
                    // Hide send emails button in test mode
                    if (sendBtn) sendBtn.classList.add('hidden');
                    
                    linksList.innerHTML = `
                        <div style="background: #fef3c7; border: 1px solid #f59e0b; border-radius: 8px; padding: 0.75rem; margin-bottom: 1rem;">
                            <strong style="color: #92400e;">âš ï¸ Test Mode Active</strong>
                            <p style="color: #92400e; font-size: 0.875rem; margin: 0.5rem 0 0 0;">
                                Emails will NOT be sent. Copy links below to test the signing flow.
                            </p>
                        </div>
                    ` + links.map((l, i) => `
                        <div class="signing-link-item" style="padding: 0.75rem 1rem; border: 1px solid var(--border-primary); border-radius: 8px; background: var(--bg-tertiary); margin-bottom: 0.5rem;">
                            <div style="display: flex; align-items: center; gap: 0.75rem; margin-bottom: 0.5rem;">
                                <div style="width: 32px; height: 32px; background: #dbeafe; border-radius: 50%; display: flex; align-items: center; justify-content: center;">
                                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#1e40af" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                        <path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"></path>
                                        <polyline points="22,6 12,13 2,6"></polyline>
                                    </svg>
                                </div>
                                <div>
                                    <strong style="display: block; font-size: 0.875rem;">${escapeHtml(l.name || l.email.split('@')[0])}</strong>
                                    <span style="color: #6b7280; font-size: 0.75rem;">${escapeHtml(l.email)}</span>
                                </div>
                            </div>
                            <div style="display: flex; gap: 0.5rem; align-items: center;">
                                <input type="text" readonly value="${escapeHtml(l.link)}" 
                                    style="flex: 1; padding: 0.5rem; border: 1px solid var(--border-primary); border-radius: 4px; font-size: 0.75rem; background: var(--bg-secondary);"
                                    onclick="this.select()">
                                <button onclick="copySigningLink(this, '${escapeHtml(l.link)}')" 
                                    style="padding: 0.5rem 1rem; background: #1e40af; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.75rem; white-space: nowrap;">
                                    Copy
                                </button>
                            </div>
                        </div>
                    `).join('');
                } else {
                    linksList.innerHTML = links.map((l, i) => `
                        <div class="signing-link-item" style="padding: 0.75rem 1rem; border: 1px solid var(--border-primary); border-radius: 8px; background: var(--bg-tertiary); display: flex; justify-content: space-between; align-items: center;">
                            <div style="display: flex; align-items: center; gap: 0.75rem;">
                                <div style="width: 32px; height: 32px; background: #dbeafe; border-radius: 50%; display: flex; align-items: center; justify-content: center;">
                                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#1e40af" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                        <path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"></path>
                                        <polyline points="22,6 12,13 2,6"></polyline>
                                    </svg>
                                </div>
                                <div>
                                    <strong style="display: block; font-size: 0.875rem;">${escapeHtml(l.name || l.email.split('@')[0])}</strong>
                                    <span style="color: #6b7280; font-size: 0.75rem;">${escapeHtml(l.email)}</span>
                                </div>
                            </div>
                            <span style="background: #dbeafe; color: #1e40af; padding: 0.25rem 0.5rem; border-radius: 4px; font-size: 0.75rem; white-space: nowrap;">
                                Signer ${i + 1}
                            </span>
                        </div>
                    `).join('');
                }

                addAuditEntry('Signing links generated for ' + links.length + ' signer(s)' + (TEST_MODE ? ' (test mode)' : ''));

                // Show rate limit info if available
                if (sessionResult.remaining_today !== undefined || sessionResult.remaining_month !== undefined) {
                    showRateLimitInfo(sessionResult.remaining_today, sessionResult.remaining_month);
                }

            } catch (err) {
                console.error('Failed to generate signing links:', err);
                errorDiv.textContent = getServerErrorMessage(err.message || err);
                errorDiv.classList.remove('hidden');
                linksList.innerHTML = '';
                // Hide Send Emails button on error - it won't work anyway
                const sendBtn = document.getElementById('btn-send-emails');
                if (sendBtn) sendBtn.classList.add('hidden');
                // Update modal title to indicate error
                const modalTitle = document.getElementById('signing-links-title');
                if (modalTitle) modalTitle.textContent = 'Unable to Send';
            }
        }

        function openSigningLinksModal() {
            document.getElementById('signing-links-modal').classList.remove('hidden');
        }

        function closeSigningLinksModal() {
            document.getElementById('signing-links-modal').classList.add('hidden');
        }

        function copySigningLink(button, link) {
            navigator.clipboard.writeText(link).then(() => {
                button.textContent = 'Copied!';
                button.classList.add('copied');
                setTimeout(() => {
                    button.textContent = 'Copy';
                    button.classList.remove('copied');
                }, 2000);
            }).catch(err => {
                console.error('Failed to copy:', err);
                showToast('Failed to copy link');
            });
        }

        async function sendSigningEmails() {
            if (!state.signingLinks || state.signingLinks.length === 0) {
                showToast('Please generate signing links first');
                return;
            }

            const sendBtn = document.getElementById('btn-send-emails');
            const spinner = sendBtn.querySelector('.btn-spinner');
            const btnText = sendBtn.querySelector('.btn-text');

            // Helper to reset button state
            const resetButton = () => {
                sendBtn.disabled = false;
                sendBtn.classList.remove('btn-loading', 'btn-success-state');
                spinner.style.display = 'none';
                btnText.textContent = 'Send Signing Requests';
                sendBtn.setAttribute('aria-busy', 'false');
            };

            // START LOADING STATE - spinner left of text (2026 UX best practice)
            sendBtn.disabled = true;
            sendBtn.classList.add('btn-loading');
            spinner.style.display = 'inline-block';
            btnText.textContent = 'Sending...';
            sendBtn.setAttribute('aria-busy', 'true');

            try {
                // Prepare invitations data
                const invitations = state.signingLinks.map(link => ({
                    recipient_id: link.recipientId.toString(),
                    name: link.name,
                    email: link.email,
                    signing_link: link.link
                }));

                // Feature 1: Get document alias and context from modal inputs
                const documentAlias = document.getElementById('document-alias')?.value?.trim() || null;
                const signingContext = document.getElementById('signing-context')?.value?.trim() || null;

                // Call /invite endpoint (with authentication)
                const response = await window.DocSign.authenticatedFetch(`${SIGNING_SERVER_URL}/invite`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        session_id: state.currentSessionId,
                        document_name: state.fileName || 'document.pdf',
                        sender_name: 'Get Signatures', // Could be from user settings
                        invitations: invitations,
                        document_alias: documentAlias,
                        signing_context: signingContext
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(errorData.message || `Server error: ${response.status}`);
                }

                const result = await response.json();

                if (result.success) {
                    // SUCCESS STATE - show checkmark animation (per Nielsen Norman Group)
                    sendBtn.classList.remove('btn-loading');
                    sendBtn.classList.add('btn-success-state');
                    btnText.textContent = 'Sent!';
                    sendBtn.setAttribute('aria-busy', 'false');

                    addAuditEntry(`Signing invitations sent to ${invitations.length} recipient(s)`);

                    // Show rate limit info if available
                    if (result.remaining_today !== undefined || result.remaining_month !== undefined) {
                        showRateLimitInfo(result.remaining_today, result.remaining_month);
                    }

                    // Brief success display, then navigate to dashboard
                    setTimeout(async () => {
                        resetButton();
                        closeSigningLinksModal();

                        // Reset document state to prevent re-sends
                        state.currentSessionId = null;
                        state.signingLinks = [];

                        // Navigate to dashboard (Sent tab) to show the sent document
                        dashboardVisible = false;
                        await toggleDashboard();
                        switchDashboardTab('sent');

                        showToast('Document sent! View it in My Documents.');
                    }, 1500);
                } else {
                    throw new Error(result.message || 'Failed to send invitations');
                }

            } catch (err) {
                console.error('Failed to send emails:', err);
                resetButton();

                const errorDiv = document.getElementById('signing-links-error');
                if (errorDiv) {
                    errorDiv.textContent = 'Failed to send emails: ' + (err.message || 'Unknown error');
                    errorDiv.classList.remove('hidden');
                }

                showToast('Failed to send emails. Check server configuration.');
            }
        }

        function showRateLimitInfo(remainingToday, remainingMonth) {
            const rateLimitDiv = document.getElementById('signing-links-rate-limit');
            if (!rateLimitDiv) return;

            const warnings = [];
            if (remainingToday !== undefined && remainingToday < 20) {
                warnings.push(`${remainingToday} emails remaining today`);
            }
            if (remainingMonth !== undefined && remainingMonth < 100) {
                warnings.push(`${remainingMonth} emails remaining this month`);
            }

            if (warnings.length > 0) {
                rateLimitDiv.innerHTML = `<strong>Rate Limit Warning:</strong> ${warnings.join(', ')}. Consider upgrading your plan if you need more capacity.`;
                rateLimitDiv.classList.remove('hidden');
            } else {
                rateLimitDiv.classList.add('hidden');
            }
        }

        // Expose signing link functions to window for onclick handlers
        window.closeSigningLinksModal = closeSigningLinksModal;
        window.sendSigningEmails = sendSigningEmails;
        window.copySigningLink = copySigningLink;

        // ============================================================
        // Feature 2: Document Dashboard Functions
        // ============================================================

        let dashboardVisible = false;

        async function toggleDashboard() {
            const dashboardSection = document.getElementById('dashboard-section');
            const mainContent = document.getElementById('main-content');
            const stepper = document.querySelector('.stepper');
            const footerActions = document.querySelector('.footer-actions');

            dashboardVisible = !dashboardVisible;

            if (dashboardVisible) {
                // Show dashboard, hide main content
                dashboardSection.classList.remove('hidden');
                mainContent.style.display = 'none';
                if (stepper) stepper.style.display = 'none';
                if (footerActions) footerActions.style.display = 'none';

                // Load documents
                await loadDashboard();
            } else {
                // Hide dashboard, show main content
                dashboardSection.classList.add('hidden');
                mainContent.style.display = '';
                if (stepper) stepper.style.display = '';
                if (footerActions) footerActions.style.display = '';
            }
        }

        // Dashboard state
        let dashboardData = null;
        let currentDashboardTab = 'sent';
        const thumbnailCache = new Map();

        // Document preview state
        let previewDoc = null;
        let previewCurrentPage = 1;
        let previewTotalPages = 1;
        let previewSessionId = null;
        let previewPdfBytes = null;

        async function loadDashboard() {
            const loadingEl = document.getElementById('dashboard-loading');
            const errorEl = document.getElementById('dashboard-error');
            const emptyEl = document.getElementById('dashboard-empty');
            const sentContent = document.getElementById('dashboard-content-sent');
            const inboxContent = document.getElementById('dashboard-content-inbox');

            // Show loading, hide others
            loadingEl.classList.remove('hidden');
            errorEl.classList.add('hidden');
            emptyEl.classList.add('hidden');
            sentContent.classList.add('hidden');
            inboxContent.classList.add('hidden');

            try {
                const response = await window.DocSign.authenticatedFetch(`${SIGNING_SERVER_URL}/my-sessions`, {
                    method: 'GET',
                    headers: { 'Content-Type': 'application/json' }
                });

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(errorData.message || `Server error: ${response.status}`);
                }

                dashboardData = await response.json();
                loadingEl.classList.add('hidden');

                // Count documents in each section
                const sentCount = (dashboardData.sent?.in_progress?.length || 0) +
                                 (dashboardData.sent?.completed?.length || 0) +
                                 (dashboardData.sent?.declined?.length || 0) +
                                 (dashboardData.sent?.expired?.length || 0) +
                                 (dashboardData.sent?.voided?.length || 0);
                const inboxCount = (dashboardData.inbox?.to_sign?.length || 0) +
                                  (dashboardData.inbox?.completed?.length || 0) +
                                  (dashboardData.inbox?.declined?.length || 0);
                const totalDocs = sentCount + inboxCount;

                // Update tab counts
                document.getElementById('sent-tab-count').textContent = sentCount > 0 ? `(${sentCount})` : '';
                document.getElementById('inbox-tab-count').textContent = inboxCount > 0 ? `(${inboxCount})` : '';

                if (totalDocs === 0) {
                    emptyEl.classList.remove('hidden');
                    return;
                }

                // Render based on current tab
                renderDashboardTab(currentDashboardTab);

            } catch (err) {
                console.error('Failed to load dashboard:', err);
                loadingEl.classList.add('hidden');
                errorEl.textContent = 'Failed to load documents: ' + (err.message || 'Unknown error');
                errorEl.classList.remove('hidden');
            }
        }

        function switchDashboardTab(tab) {
            currentDashboardTab = tab;

            // Update tab styles
            document.getElementById('tab-sent').classList.toggle('active', tab === 'sent');
            document.getElementById('tab-inbox').classList.toggle('active', tab === 'inbox');
            document.getElementById('tab-sent').style.borderBottomColor = tab === 'sent' ? '#3b82f6' : 'transparent';
            document.getElementById('tab-inbox').style.borderBottomColor = tab === 'inbox' ? '#3b82f6' : 'transparent';
            document.getElementById('tab-sent').style.color = tab === 'sent' ? 'var(--text-primary)' : 'var(--text-secondary)';
            document.getElementById('tab-inbox').style.color = tab === 'inbox' ? 'var(--text-primary)' : 'var(--text-secondary)';

            renderDashboardTab(tab);
        }

        function renderDashboardTab(tab) {
            const sentContent = document.getElementById('dashboard-content-sent');
            const inboxContent = document.getElementById('dashboard-content-inbox');

            if (tab === 'sent') {
                sentContent.classList.remove('hidden');
                inboxContent.classList.add('hidden');

                if (dashboardData?.sent) {
                    // Render "Needs Action" section first for declined docs (most urgent)
                    renderDocumentSection('needs-action', dashboardData.sent.declined || [], 'declined', 'sent');
                    renderDocumentSection('in-progress', dashboardData.sent.in_progress || [], 'pending', 'sent');
                    renderDocumentSection('completed', dashboardData.sent.completed || [], 'completed', 'sent');
                    renderDocumentSection('expired', dashboardData.sent.expired || [], 'expired', 'sent');
                    renderDocumentSection('voided', dashboardData.sent.voided || [], 'voided', 'sent');
                }
            } else {
                sentContent.classList.add('hidden');
                inboxContent.classList.remove('hidden');

                if (dashboardData?.inbox) {
                    renderDocumentSection('to-sign', dashboardData.inbox.to_sign || [], 'to_sign', 'inbox');
                    renderDocumentSection('inbox-completed', dashboardData.inbox.completed || [], 'completed', 'inbox');
                    renderDocumentSection('inbox-declined', dashboardData.inbox.declined || [], 'declined', 'inbox');
                }
            }
        }

        function renderDocumentSection(sectionId, documents, statusType, source) {
            const sectionEl = document.getElementById(`dashboard-${sectionId}`);
            const listEl = document.getElementById(`${sectionId}-list`);
            const countEl = document.getElementById(`${sectionId}-count`);

            if (documents.length === 0) {
                sectionEl.classList.add('hidden');
                return;
            }

            sectionEl.classList.remove('hidden');
            countEl.textContent = `(${documents.length})`;

            listEl.innerHTML = documents.map(doc => renderDocumentCard(doc, statusType, source)).join('');

            // Load thumbnails after rendering (use source prefix for unique IDs)
            documents.forEach(doc => {
                if (doc.session_id) {
                    loadThumbnail(doc.session_id, source);
                }
            });
        }

        function renderDocumentCard(doc, statusType, source) {
            const displayName = doc.document_alias || doc.filename;
            const contextDisplay = doc.signing_context ? `<div style="font-size: 0.75rem; color: var(--text-tertiary); margin-top: 0.25rem;">${escapeHtml(doc.signing_context)}</div>` : '';

            const progressPercent = doc.recipients_total > 0
                ? Math.round((doc.recipients_signed / doc.recipients_total) * 100)
                : 0;

            const createdDate = new Date(doc.created_at).toLocaleDateString();
            const expiresDate = doc.expires_at ? new Date(doc.expires_at).toLocaleDateString() : '';

            // Recipient status pills (for sent docs)
            let recipientPills = '';
            if (source === 'sent' && doc.recipients) {
                recipientPills = doc.recipients.map(r => {
                    const statusColor = r.signed ? '#10b981' : (statusType === 'declined' ? '#ef4444' : '#f59e0b');
                    const statusIcon = r.signed ? 'âœ“' : (statusType === 'declined' ? 'âœ—' : 'â—‹');
                    return `<span style="display: inline-flex; align-items: center; gap: 0.25rem; padding: 0.125rem 0.5rem; background: ${statusColor}20; color: ${statusColor}; border-radius: 999px; font-size: 0.7rem; font-weight: 500;">${statusIcon} ${escapeHtml(r.name)}</span>`;
                }).join(' ');
            }

            // For inbox items, show sender info
            let senderInfo = '';
            if (source === 'inbox' && doc.sender_email) {
                senderInfo = `<div style="font-size: 0.75rem; color: var(--text-secondary); margin-top: 0.25rem;">From: ${escapeHtml(doc.sender_email)}</div>`;
            }

            // My status for inbox items
            let myStatus = '';
            if (source === 'inbox' && doc.my_status) {
                const statusColors = { pending: '#f59e0b', signed: '#10b981', declined: '#ef4444' };
                const statusIcons = { pending: 'â—‹', signed: 'âœ“', declined: 'âœ—' };
                const color = statusColors[doc.my_status] || '#6b7280';
                const icon = statusIcons[doc.my_status] || 'â—‹';
                myStatus = `<span style="display: inline-flex; align-items: center; gap: 0.25rem; padding: 0.125rem 0.5rem; background: ${color}20; color: ${color}; border-radius: 999px; font-size: 0.7rem; font-weight: 500;">${icon} ${doc.my_status}</span>`;
            }

            // Action button based on status
            let actionButton = '';
            if (statusType === 'to_sign' && doc.signing_url) {
                actionButton = `<a href="${doc.signing_url}" class="btn btn-primary" style="padding: 0.375rem 0.75rem; font-size: 0.75rem;">Sign Now</a>`;
            } else if (statusType === 'voided') {
                // Voided documents show badge only, no actions
                actionButton = `<span style="display: inline-flex; align-items: center; padding: 0.25rem 0.75rem; background: #9ca3af20; color: #6b7280; border-radius: 4px; font-size: 0.75rem; font-weight: 600;">VOIDED</span>`;
            } else if (statusType === 'declined' && source === 'sent') {
                // Declined sent docs (Needs Action) get Preview + Revise/Restart + Discard buttons
                const anyoneSigned = doc.recipients_signed > 0;
                if (anyoneSigned) {
                    // Some have signed before decline - show Restart option
                    actionButton = `
                        <button onclick="openDocPreview('${doc.session_id}')" class="btn btn-secondary" style="padding: 0.375rem 0.75rem; font-size: 0.75rem; margin-right: 0.5rem;">Preview</button>
                        <button onclick="openRestartConfirm('${doc.session_id}')" class="btn" style="padding: 0.375rem 0.75rem; font-size: 0.75rem; background: #f59e0b; color: white; border: none; border-radius: 6px; margin-right: 0.5rem;">Restart</button>
                        <button onclick="openDiscardConfirm('${doc.session_id}')" class="btn" style="padding: 0.375rem 0.75rem; font-size: 0.75rem; background: #ef4444; color: white; border: none; border-radius: 6px;">Discard</button>`;
                } else {
                    // No one signed - can revise
                    actionButton = `
                        <button onclick="openDocPreview('${doc.session_id}')" class="btn btn-secondary" style="padding: 0.375rem 0.75rem; font-size: 0.75rem; margin-right: 0.5rem;">Preview</button>
                        <button onclick="openReviseConfirm('${doc.session_id}')" class="btn" style="padding: 0.375rem 0.75rem; font-size: 0.75rem; background: #3b82f6; color: white; border: none; border-radius: 6px; margin-right: 0.5rem;">Revise</button>
                        <button onclick="openDiscardConfirm('${doc.session_id}')" class="btn" style="padding: 0.375rem 0.75rem; font-size: 0.75rem; background: #ef4444; color: white; border: none; border-radius: 6px;">Discard</button>`;
                }
            } else if (statusType === 'pending' && source === 'sent') {
                // In-progress sent docs get Preview + Revise/Restart + Discard buttons
                const anyoneSigned = doc.recipients_signed > 0;
                if (anyoneSigned) {
                    // Some have signed - show Revise & Restart option
                    actionButton = `
                        <button onclick="openDocPreview('${doc.session_id}')" class="btn btn-secondary" style="padding: 0.375rem 0.75rem; font-size: 0.75rem; margin-right: 0.5rem;">Preview</button>
                        <button disabled title="Some signers have already signed" class="btn btn-secondary" style="padding: 0.375rem 0.75rem; font-size: 0.75rem; opacity: 0.5; cursor: not-allowed; margin-right: 0.5rem;">Revise</button>
                        <button onclick="openRestartConfirm('${doc.session_id}')" class="btn" style="padding: 0.375rem 0.75rem; font-size: 0.75rem; background: #f59e0b; color: white; border: none; border-radius: 6px; margin-right: 0.5rem;">Restart</button>
                        <button onclick="openDiscardConfirm('${doc.session_id}')" class="btn" style="padding: 0.375rem 0.75rem; font-size: 0.75rem; background: #ef4444; color: white; border: none; border-radius: 6px;">Discard</button>`;
                } else {
                    // No one has signed - full revision available
                    actionButton = `
                        <button onclick="openDocPreview('${doc.session_id}')" class="btn btn-secondary" style="padding: 0.375rem 0.75rem; font-size: 0.75rem; margin-right: 0.5rem;">Preview</button>
                        <button onclick="openReviseConfirm('${doc.session_id}')" class="btn" style="padding: 0.375rem 0.75rem; font-size: 0.75rem; background: #3b82f6; color: white; border: none; border-radius: 6px; margin-right: 0.5rem;">Revise</button>
                        <button onclick="openDiscardConfirm('${doc.session_id}')" class="btn" style="padding: 0.375rem 0.75rem; font-size: 0.75rem; background: #ef4444; color: white; border: none; border-radius: 6px;">Discard</button>`;
                }
            } else if (statusType === 'completed' || source === 'sent') {
                actionButton = `<button onclick="openDocPreview('${doc.session_id}')" class="btn btn-secondary" style="padding: 0.375rem 0.75rem; font-size: 0.75rem;">Preview</button>`;
            }

            return `
                <div style="display: flex; gap: 1rem; padding: 1rem; background: var(--bg-secondary); border: 1px solid var(--border-primary); border-radius: 8px; transition: box-shadow 0.2s; cursor: pointer;" onclick="openDocPreview('${doc.session_id}')">
                    <!-- Thumbnail (ID includes source to avoid duplicates between Sent/Inbox) -->
                    <div id="thumb-${source}-${doc.session_id}" style="width: 80px; min-width: 80px; height: 100px; background: var(--bg-tertiary); border-radius: 4px; display: flex; align-items: center; justify-content: center; overflow: hidden;">
                        <div class="spinner" style="width: 24px; height: 24px; border-width: 2px;"></div>
                    </div>

                    <!-- Document Info -->
                    <div style="flex: 1; min-width: 0;">
                        <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 0.5rem;">
                            <div style="flex: 1; min-width: 0;">
                                <div style="font-weight: 600; color: var(--text-primary); white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${escapeHtml(displayName)}</div>
                                ${contextDisplay}
                                ${doc.document_alias ? `<div style="font-size: 0.75rem; color: var(--text-tertiary);">${escapeHtml(doc.filename)}</div>` : ''}
                                ${senderInfo}
                            </div>
                            <div style="text-align: right; font-size: 0.75rem; color: var(--text-secondary); white-space: nowrap; margin-left: 1rem;">
                                <div>Created: ${createdDate}</div>
                                ${expiresDate && statusType !== 'completed' ? `<div>Expires: ${expiresDate}</div>` : ''}
                            </div>
                        </div>
                        ${recipientPills ? `<div style="display: flex; flex-wrap: wrap; gap: 0.5rem; margin-bottom: 0.5rem;">${recipientPills}</div>` : ''}
                        ${myStatus ? `<div style="margin-bottom: 0.5rem;">${myStatus}</div>` : ''}
                        ${statusType === 'pending' && source === 'sent' ? `
                            <div style="background: var(--bg-tertiary); border-radius: 4px; height: 6px; overflow: hidden; margin-bottom: 0.25rem;">
                                <div style="background: #f59e0b; height: 100%; width: ${progressPercent}%; transition: width 0.3s;"></div>
                            </div>
                            <div style="font-size: 0.75rem; color: var(--text-secondary);">
                                ${doc.recipients_signed} of ${doc.recipients_total} signed (${progressPercent}%)
                            </div>
                        ` : ''}
                        <div style="display: flex; justify-content: flex-end; margin-top: 0.5rem;" onclick="event.stopPropagation()">
                            ${actionButton}
                        </div>
                    </div>
                </div>
            `;
        }

        // Thumbnail loading with PDF.js
        // source parameter ensures unique element IDs between Sent/Inbox tabs
        async function loadThumbnail(sessionId, source = 'sent') {
            const thumbEl = document.getElementById(`thumb-${source}-${sessionId}`);
            if (!thumbEl) return;

            // Check cache first (cache key is just sessionId since PDF is same)
            if (thumbnailCache.has(sessionId)) {
                thumbEl.innerHTML = `<img src="${thumbnailCache.get(sessionId)}" style="width: 100%; height: 100%; object-fit: cover;" alt="Document thumbnail">`;
                return;
            }

            try {
                // Fetch PDF from download endpoint (requires authentication)
                const response = await window.DocSign.authenticatedFetch(`${SIGNING_SERVER_URL}/session/${sessionId}/download`);
                if (!response.ok) {
                    thumbEl.innerHTML = `<span style="font-size: 2rem;">ðŸ“„</span>`;
                    return;
                }

                const pdfBytes = await response.arrayBuffer();
                const pdfDoc = await pdfjsLib.getDocument({ data: pdfBytes }).promise;
                const page = await pdfDoc.getPage(1);

                const viewport = page.getViewport({ scale: 1 });
                const scale = 80 / viewport.width;
                const scaledViewport = page.getViewport({ scale });

                const canvas = document.createElement('canvas');
                canvas.width = scaledViewport.width;
                canvas.height = scaledViewport.height;

                await page.render({
                    canvasContext: canvas.getContext('2d'),
                    viewport: scaledViewport
                }).promise;

                const thumbnailUrl = canvas.toDataURL('image/jpeg', 0.7);
                thumbnailCache.set(sessionId, thumbnailUrl);

                thumbEl.innerHTML = `<img src="${thumbnailUrl}" style="width: 100%; height: 100%; object-fit: cover;" alt="Document thumbnail">`;
                pdfDoc.destroy();

            } catch (err) {
                console.error('Failed to load thumbnail:', err);
                thumbEl.innerHTML = `<span style="font-size: 2rem;">ðŸ“„</span>`;
            }
        }

        // Document Preview Modal functions
        async function openDocPreview(sessionId) {
            const modal = document.getElementById('doc-preview-modal');
            const loadingEl = document.getElementById('doc-preview-loading');
            const canvas = document.getElementById('doc-preview-canvas');

            modal.classList.remove('hidden');
            loadingEl.style.display = 'block';
            canvas.style.display = 'none';
            previewSessionId = sessionId;
            previewCurrentPage = 1;

            try {
                // Fetch PDF from download endpoint (requires authentication)
                const response = await window.DocSign.authenticatedFetch(`${SIGNING_SERVER_URL}/session/${sessionId}/download`);
                if (!response.ok) throw new Error('Failed to fetch document');

                previewPdfBytes = await response.arrayBuffer();
                previewDoc = await pdfjsLib.getDocument({ data: previewPdfBytes }).promise;
                previewTotalPages = previewDoc.numPages;

                loadingEl.style.display = 'none';
                canvas.style.display = 'block';

                await renderPreviewPage(1);

            } catch (err) {
                console.error('Failed to load preview:', err);
                loadingEl.innerHTML = `<p style="color: #ef4444;">Failed to load document preview</p>`;
            }
        }

        async function renderPreviewPage(pageNum) {
            if (!previewDoc) return;

            const canvas = document.getElementById('doc-preview-canvas');
            const page = await previewDoc.getPage(pageNum);

            const containerWidth = document.getElementById('doc-preview-content').clientWidth - 32;
            const viewport = page.getViewport({ scale: 1 });
            const scale = Math.min(containerWidth / viewport.width, 1.5);
            const scaledViewport = page.getViewport({ scale });

            canvas.width = scaledViewport.width;
            canvas.height = scaledViewport.height;

            await page.render({
                canvasContext: canvas.getContext('2d'),
                viewport: scaledViewport
            }).promise;

            document.getElementById('doc-preview-page-info').textContent = `Page ${pageNum} of ${previewTotalPages}`;
            document.getElementById('doc-preview-prev').disabled = pageNum <= 1;
            document.getElementById('doc-preview-next').disabled = pageNum >= previewTotalPages;
        }

        function previewPrevPage() {
            if (previewCurrentPage > 1) {
                previewCurrentPage--;
                renderPreviewPage(previewCurrentPage);
            }
        }

        function previewNextPage() {
            if (previewCurrentPage < previewTotalPages) {
                previewCurrentPage++;
                renderPreviewPage(previewCurrentPage);
            }
        }

        function closeDocPreview() {
            document.getElementById('doc-preview-modal').classList.add('hidden');
            if (previewDoc) {
                previewDoc.destroy();
                previewDoc = null;
            }
            previewPdfBytes = null;
            previewSessionId = null;
        }

        function downloadPreviewDoc() {
            if (!previewPdfBytes || !previewSessionId) return;

            const blob = new Blob([previewPdfBytes], { type: 'application/pdf' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `document-${previewSessionId}.pdf`;
            a.click();
            URL.revokeObjectURL(url);
        }

        // Discard/Void Document Functions
        function openDiscardConfirm(sessionId) {
            // Create modal overlay
            const modalOverlay = document.createElement('div');
            modalOverlay.id = 'discard-modal-overlay';
            modalOverlay.className = 'modal-overlay';
            modalOverlay.style.cssText = 'position: fixed; inset: 0; background: rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center; z-index: 1000;';
            modalOverlay.innerHTML = `
                <div class="modal" style="max-width: 400px; background: var(--bg-primary); border-radius: 12px; padding: 1.5rem; box-shadow: 0 20px 50px rgba(0,0,0,0.3);">
                    <h2 style="color: #dc2626; margin: 0 0 1rem 0; font-size: 1.25rem;">Discard Document?</h2>
                    <p style="margin-bottom: 1rem; color: var(--text-secondary); line-height: 1.5;">
                        This will permanently cancel this signing request. All recipients will be notified
                        and their signing links will no longer work.
                    </p>
                    <p style="font-weight: 600; margin-bottom: 1rem; color: var(--text-primary);">This cannot be undone.</p>

                    <label style="display: block; margin-bottom: 0.5rem; font-weight: 500; color: var(--text-secondary);">Reason (optional)</label>
                    <textarea id="void-reason" rows="2" placeholder="e.g., Sending updated version..."
                        style="width: 100%; padding: 0.75rem; border: 1px solid var(--border-primary); border-radius: 6px; resize: vertical; font-family: inherit; background: var(--bg-secondary); color: var(--text-primary);"></textarea>

                    <div style="display: flex; gap: 0.75rem; justify-content: flex-end; margin-top: 1.5rem;">
                        <button onclick="closeDiscardModal()" class="btn btn-secondary" style="padding: 0.5rem 1rem;">
                            Cancel
                        </button>
                        <button onclick="submitVoid('${sessionId}')" class="btn" style="padding: 0.5rem 1rem; background: #dc2626; color: white; border: none; border-radius: 6px;">
                            Discard Document
                        </button>
                    </div>
                </div>
            `;
            document.body.appendChild(modalOverlay);
        }

        function closeDiscardModal() {
            const modal = document.getElementById('discard-modal-overlay');
            if (modal) modal.remove();
        }

        async function submitVoid(sessionId) {
            const reasonEl = document.getElementById('void-reason');
            const reason = reasonEl?.value.trim() || null;

            // Disable button and show loading
            const submitBtn = document.querySelector('#discard-modal-overlay button[onclick*="submitVoid"]');
            if (submitBtn) {
                submitBtn.disabled = true;
                submitBtn.textContent = 'Discarding...';
            }

            try {
                const response = await window.DocSign.authenticatedFetch(
                    `${SIGNING_SERVER_URL}/session/${sessionId}/void`,
                    {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ reason })
                    }
                );

                if (response.ok) {
                    showToast('Document discarded. All parties have been notified.', 'success');
                    closeDiscardModal();
                    loadDashboard(); // Refresh dashboard
                } else {
                    const errorData = await response.json().catch(() => ({}));
                    showToast(errorData.message || 'Failed to discard document.', 'error');
                    if (submitBtn) {
                        submitBtn.disabled = false;
                        submitBtn.textContent = 'Discard Document';
                    }
                }
            } catch (err) {
                console.error('Void error:', err);
                showToast('Failed to discard document. Please try again.', 'error');
                if (submitBtn) {
                    submitBtn.disabled = false;
                    submitBtn.textContent = 'Discard Document';
                }
            }
        }

        // escapeHtml already defined above - removed duplicate

        // Revise Document Functions
        function openReviseConfirm(sessionId) {
            const modalOverlay = document.createElement('div');
            modalOverlay.id = 'revise-modal-overlay';
            modalOverlay.className = 'modal-overlay';
            modalOverlay.style.cssText = 'position: fixed; inset: 0; background: rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center; z-index: 1000;';
            modalOverlay.innerHTML = `
                <div class="modal" style="max-width: 450px; background: var(--bg-primary); border-radius: 12px; padding: 1.5rem; box-shadow: 0 20px 50px rgba(0,0,0,0.3);">
                    <h2 style="color: #3b82f6; margin: 0 0 1rem 0; font-size: 1.25rem;">Revise Document</h2>
                    <p style="margin-bottom: 1rem; color: var(--text-secondary); line-height: 1.5;">
                        Send updated invitations to all signers. Since no one has signed yet,
                        previous signing links will be invalidated and new links will be sent.
                    </p>

                    <label style="display: block; margin-bottom: 0.5rem; font-weight: 500; color: var(--text-secondary);">Message to signers (optional)</label>
                    <textarea id="revise-message" rows="3" placeholder="e.g., Please note the updated terms in section 3..."
                        style="width: 100%; padding: 0.75rem; border: 1px solid var(--border-primary); border-radius: 6px; resize: vertical; font-family: inherit; background: var(--bg-secondary); color: var(--text-primary);"></textarea>

                    <div style="display: flex; gap: 0.75rem; justify-content: flex-end; margin-top: 1.5rem;">
                        <button onclick="closeReviseModal()" class="btn btn-secondary" style="padding: 0.5rem 1rem;">
                            Cancel
                        </button>
                        <button onclick="submitRevise('${sessionId}')" class="btn" style="padding: 0.5rem 1rem; background: #3b82f6; color: white; border: none; border-radius: 6px;">
                            Send Updated Invitations
                        </button>
                    </div>
                </div>
            `;
            document.body.appendChild(modalOverlay);
        }

        function closeReviseModal() {
            const modal = document.getElementById('revise-modal-overlay');
            if (modal) modal.remove();
        }

        async function submitRevise(sessionId) {
            const messageEl = document.getElementById('revise-message');
            const message = messageEl?.value.trim() || null;

            const submitBtn = document.querySelector('#revise-modal-overlay button[onclick*="submitRevise"]');
            if (submitBtn) {
                submitBtn.disabled = true;
                submitBtn.textContent = 'Sending...';
            }

            try {
                // Fetch current session to get fields
                const sessionResp = await window.DocSign.authenticatedFetch(`${SIGNING_SERVER_URL}/session/${sessionId}`);
                if (!sessionResp.ok) throw new Error('Failed to fetch session');
                const sessionData = await sessionResp.json();

                const response = await window.DocSign.authenticatedFetch(
                    `${SIGNING_SERVER_URL}/session/${sessionId}/revise`,
                    {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            fields: sessionData.fields || [],
                            message: message
                        })
                    }
                );

                if (response.ok) {
                    showToast('Document revised. New invitations sent to all signers.', 'success');
                    closeReviseModal();
                    loadDashboard();
                } else {
                    const errorData = await response.json().catch(() => ({}));
                    showToast(errorData.message || 'Failed to revise document.', 'error');
                    if (submitBtn) {
                        submitBtn.disabled = false;
                        submitBtn.textContent = 'Send Updated Invitations';
                    }
                }
            } catch (err) {
                console.error('Revise error:', err);
                showToast('Failed to revise document. Please try again.', 'error');
                if (submitBtn) {
                    submitBtn.disabled = false;
                    submitBtn.textContent = 'Send Updated Invitations';
                }
            }
        }

        // Restart Document Functions (voids existing signatures)
        function openRestartConfirm(sessionId) {
            const modalOverlay = document.createElement('div');
            modalOverlay.id = 'restart-modal-overlay';
            modalOverlay.className = 'modal-overlay';
            modalOverlay.style.cssText = 'position: fixed; inset: 0; background: rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center; z-index: 1000;';
            modalOverlay.innerHTML = `
                <div class="modal" style="max-width: 450px; background: var(--bg-primary); border-radius: 12px; padding: 1.5rem; box-shadow: 0 20px 50px rgba(0,0,0,0.3);">
                    <h2 style="color: #f59e0b; margin: 0 0 1rem 0; font-size: 1.25rem;">Restart Document Signing</h2>

                    <div style="background: #fef3c7; border: 1px solid #fcd34d; border-radius: 8px; padding: 1rem; margin-bottom: 1rem;">
                        <p style="margin: 0; color: #92400e; font-weight: 500;">
                            âš ï¸ This will void all existing signatures
                        </p>
                        <p style="margin: 0.5rem 0 0 0; font-size: 0.875rem; color: #b45309;">
                            All signers will need to sign again. They will receive new signing links.
                        </p>
                    </div>

                    <p style="margin-bottom: 1rem; color: var(--text-secondary); line-height: 1.5;">
                        Use this option when you need to make changes after some recipients have already signed.
                    </p>

                    <label style="display: block; margin-bottom: 0.5rem; font-weight: 500; color: var(--text-secondary);">Message to signers (optional)</label>
                    <textarea id="restart-message" rows="3" placeholder="e.g., The document has been updated and requires new signatures..."
                        style="width: 100%; padding: 0.75rem; border: 1px solid var(--border-primary); border-radius: 6px; resize: vertical; font-family: inherit; background: var(--bg-secondary); color: var(--text-primary);"></textarea>

                    <div style="display: flex; gap: 0.75rem; justify-content: flex-end; margin-top: 1.5rem;">
                        <button onclick="closeRestartModal()" class="btn btn-secondary" style="padding: 0.5rem 1rem;">
                            Cancel
                        </button>
                        <button onclick="submitRestart('${sessionId}')" class="btn" style="padding: 0.5rem 1rem; background: #f59e0b; color: white; border: none; border-radius: 6px;">
                            Restart & Send New Invitations
                        </button>
                    </div>
                </div>
            `;
            document.body.appendChild(modalOverlay);
        }

        function closeRestartModal() {
            const modal = document.getElementById('restart-modal-overlay');
            if (modal) modal.remove();
        }

        async function submitRestart(sessionId) {
            const messageEl = document.getElementById('restart-message');
            const message = messageEl?.value.trim() || null;

            const submitBtn = document.querySelector('#restart-modal-overlay button[onclick*="submitRestart"]');
            if (submitBtn) {
                submitBtn.disabled = true;
                submitBtn.textContent = 'Restarting...';
            }

            try {
                // Fetch current session to get fields
                const sessionResp = await window.DocSign.authenticatedFetch(`${SIGNING_SERVER_URL}/session/${sessionId}`);
                if (!sessionResp.ok) throw new Error('Failed to fetch session');
                const sessionData = await sessionResp.json();

                const response = await window.DocSign.authenticatedFetch(
                    `${SIGNING_SERVER_URL}/session/${sessionId}/restart`,
                    {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            fields: sessionData.fields || [],
                            message: message
                        })
                    }
                );

                if (response.ok) {
                    showToast('Document restarted. All previous signatures voided. New invitations sent.', 'success');
                    closeRestartModal();
                    loadDashboard();
                } else {
                    const errorData = await response.json().catch(() => ({}));
                    showToast(errorData.message || 'Failed to restart document.', 'error');
                    if (submitBtn) {
                        submitBtn.disabled = false;
                        submitBtn.textContent = 'Restart & Send New Invitations';
                    }
                }
            } catch (err) {
                console.error('Restart error:', err);
                showToast('Failed to restart document. Please try again.', 'error');
                if (submitBtn) {
                    submitBtn.disabled = false;
                    submitBtn.textContent = 'Restart & Send New Invitations';
                }
            }
        }

        // Expose dashboard functions to window
        window.toggleDashboard = toggleDashboard;
        window.loadDashboard = loadDashboard;
        window.switchDashboardTab = switchDashboardTab;
        window.openDocPreview = openDocPreview;
        window.closeDocPreview = closeDocPreview;
        window.previewPrevPage = previewPrevPage;
        window.previewNextPage = previewNextPage;
        window.downloadPreviewDoc = downloadPreviewDoc;
        window.openDiscardConfirm = openDiscardConfirm;
        window.closeDiscardModal = closeDiscardModal;
        window.submitVoid = submitVoid;
        window.openReviseConfirm = openReviseConfirm;
        window.closeReviseModal = closeReviseModal;
        window.submitRevise = submitRevise;
        window.openRestartConfirm = openRestartConfirm;
        window.closeRestartModal = closeRestartModal;
        window.submitRestart = submitRestart;

        // Remote Signing - Encryption/Decryption using Web Crypto
        const SIGNING_SERVER_URL = 'https://api.getsignatures.org';

        // Test Mode: Add ?test_mode=true to URL to skip email sending and show links directly
        // Useful for testing the full flow without wasting Resend credits
        const TEST_MODE = new URLSearchParams(window.location.search).has('test_mode');
        if (TEST_MODE) {
            console.log('%cðŸ§ª TEST MODE ENABLED', 'background: #fef3c7; color: #92400e; padding: 4px 8px; border-radius: 4px; font-weight: bold;');
            console.log('Email sending will be skipped. Signing links will be shown directly.');
        }

        async function generateEncryptionKey() {
            return await crypto.subtle.generateKey(
                { name: 'AES-GCM', length: 256 },
                true, // extractable
                ['encrypt', 'decrypt']
            );
        }

        async function exportKeyToBase64(key) {
            const exported = await crypto.subtle.exportKey('raw', key);
            return btoa(String.fromCharCode(...new Uint8Array(exported)));
        }

        async function importKeyFromBase64(base64Key) {
            const keyData = Uint8Array.from(atob(base64Key), c => c.charCodeAt(0));
            return await crypto.subtle.importKey(
                'raw',
                keyData,
                { name: 'AES-GCM' },
                true,
                ['encrypt', 'decrypt']
            );
        }

        async function encryptDocument(pdfBytes, key) {
            const iv = crypto.getRandomValues(new Uint8Array(12));
            const encrypted = await crypto.subtle.encrypt(
                { name: 'AES-GCM', iv },
                key,
                pdfBytes
            );
            // Prepend IV to encrypted data
            const combined = new Uint8Array(iv.length + encrypted.byteLength);
            combined.set(iv);
            combined.set(new Uint8Array(encrypted), iv.length);
            return btoa(String.fromCharCode(...combined));
        }

        async function decryptDocument(encryptedBase64, key) {
            const combined = Uint8Array.from(atob(encryptedBase64), c => c.charCodeAt(0));
            const iv = combined.slice(0, 12);
            const encrypted = combined.slice(12);
            const decrypted = await crypto.subtle.decrypt(
                { name: 'AES-GCM', iv },
                key,
                encrypted
            );
            return new Uint8Array(decrypted);
        }

        async function createSigningSession() {
            try {
                // Generate encryption key
                const key = await generateEncryptionKey();
                const keyBase64 = await exportKeyToBase64(key);

                // Encrypt the current PDF
                const encryptedDoc = await encryptDocument(state.pdfBytes, key);

                // Bug #0 fix: Helper to sanitize numeric values (NaN/undefined become 0)
                const sanitizeNum = (val, defaultVal = 0) => {
                    const num = Number(val);
                    return (Number.isFinite(num) && !Number.isNaN(num)) ? num : defaultVal;
                };

                // Prepare session data with defensive fallbacks
                const sessionData = {
                    encrypted_document: encryptedDoc,
                    metadata: {
                        filename: state.filename || 'document.pdf',
                        page_count: sanitizeNum(state.totalPages, 1),
                        created_at: new Date().toISOString(),
                        created_by: 'Get Signatures'
                    },
                    recipients: state.recipients.map(r => ({
                        id: String(r.id),
                        name: r.name || 'Unknown',
                        email: r.email,
                        role: r.role || 'signer',
                        signed: false
                    })),
                    fields: state.placedFields.map(f => {
                        const pageDims = state.pageDimensions[f.page];
                        const canvasWidth = sanitizeNum(pageDims?.canvasWidth, 800);
                        const canvasHeight = sanitizeNum(pageDims?.canvasHeight, 1000);
                        // Ensure we have valid positions (avoid NaN/Infinity)
                        const x = sanitizeNum(f.x, 0);
                        const y = sanitizeNum(f.y, 0);
                        const w = sanitizeNum(f.width, 100);
                        const h = sanitizeNum(f.height, 50);
                        return {
                            id: String(f.id),
                            field_type: f.type || 'signature',
                            recipient_id: String(f.recipientId),
                            page: sanitizeNum(f.page, 1),
                            x_percent: sanitizeNum((x / canvasWidth) * 100, 10),
                            y_percent: sanitizeNum((y / canvasHeight) * 100, 10),
                            width_percent: sanitizeNum((w / canvasWidth) * 100, 20),
                            height_percent: sanitizeNum((h / canvasHeight) * 100, 5),
                            required: f.required || false,
                            value: f.value || null
                        };
                    }),
                    expiry_hours: parseInt(document.getElementById('expiration-select')?.value || '168') || 168
                };

                // Create session on server (with authentication)
                const response = await window.DocSign.authenticatedFetch(`${SIGNING_SERVER_URL}/session`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(sessionData)
                });

                const result = await response.json();
                if (!result.success) {
                    throw new Error(result.message || 'Failed to create session');
                }

                // Store session info
                state.remoteSession.sessionId = result.session_id;
                state.remoteSession.encryptionKey = key;

                // Return signing links for each signer
                const baseUrl = window.location.origin + window.location.pathname;
                const signingLinks = state.recipients
                    .filter(r => r.role === 'signer')
                    .map(r => ({
                        recipient: r,
                        link: `${baseUrl}#sign=${result.session_id}&key=${encodeURIComponent(keyBase64)}&r=${r.id}`
                    }));

                return { sessionId: result.session_id, keyBase64, signingLinks };
            } catch (err) {
                console.error('Failed to create signing session:', err);
                throw err;
            }
        }

        // TODO: Re-enable encryption once basic signing flow is verified working
        // See Bug #14 investigation - crypto was causing OperationError
        async function loadRemoteSession(sessionId, recipientId, token = null) {
            try {
                // Build URL with token if available
                let apiUrl = `${SIGNING_SERVER_URL}/session/${sessionId}`;
                if (token) {
                    apiUrl += `?token=${encodeURIComponent(token)}`;
                }
                console.log('[Signing] Fetching session from:', apiUrl);

                // Fetch session from server (token in URL provides authentication)
                const response = await fetch(apiUrl);
                const result = await response.json();

                if (!result.success || !result.session) {
                    // Check for expired session
                    if (response.status === 410) {
                        throw new Error('This signing request has expired');
                    }
                    throw new Error(result.message || 'Session not found');
                }

                // Check expiration on client side as well
                if (result.session.expires_at) {
                    const expiresAt = new Date(result.session.expires_at);
                    if (expiresAt < new Date()) {
                        throw new Error('This signing request has expired');
                    }
                    // Store expiration for display
                    state.remoteSession.expiresAt = result.session.expires_at;
                }

                // Decode base64 document (no decryption - Bug #14 fix)
                // The document is stored as plain base64, not encrypted
                // Use SOTA base64ToUint8Array helper for proper decoding
                const base64Doc = result.session.encrypted_document;
                const originalBytes = base64ToUint8Array(base64Doc);

                // CRITICAL: Create copies BEFORE any operation that might detach the buffer
                // When Uint8Array is passed to WASM or PDF.js, the underlying ArrayBuffer
                // gets transferred/detached, making the original unusable.
                // See KNOWN_ISSUES.md ISSUE-023 for full explanation.
                const bytesForPdfJs = originalBytes.slice();   // Copy for PDF.js rendering
                const bytesForDocSign = originalBytes.slice(); // Copy for DocSign WASM signing

                // Store session state
                state.remoteSession.sessionId = sessionId;
                state.remoteSession.encryptionKey = null;  // No encryption
                state.remoteSession.isRemoteSigner = true;
                state.remoteSession.recipientId = recipientId;

                // Load the document (use DocSign copy - won't be detached by PDF.js)
                state.pdfBytes = bytesForDocSign;
                state.filename = result.session.metadata.filename;
                state.recipients = result.session.recipients.map(r => ({
                    id: parseInt(r.id),
                    name: r.name,
                    email: r.email,
                    role: r.role
                }));

                // Convert percentage-based fields to absolute positions
                // (will be finalized after PDF renders)
                state.placedFields = result.session.fields.map(f => ({
                    id: parseFloat(f.id) || Date.now() + Math.random(),
                    type: f.field_type,
                    recipientId: parseInt(f.recipient_id),
                    page: f.page,
                    xPercent: f.x_percent,
                    yPercent: f.y_percent,
                    widthPercent: f.width_percent,
                    heightPercent: f.height_percent,
                    required: f.required,
                    value: f.value
                }));

                // Load PDF with PDF.js
                // Use PDF.js copy (it will detach this buffer, but we don't need it anymore)
                const loadingTask = pdfjsLib.getDocument({ data: bytesForPdfJs });
                state.pdfDoc = await loadingTask.promise;
                state.totalPages = state.pdfDoc.numPages;

                // Cache page dimensions for coordinate conversion
                for (let i = 1; i <= state.totalPages; i++) {
                    const page = await state.pdfDoc.getPage(i);
                    const viewport = page.getViewport({ scale: state.scale });
                    state.pageDimensions[i] = {
                        width: viewport.width / state.scale,
                        height: viewport.height / state.scale,
                        canvasWidth: viewport.width,
                        canvasHeight: viewport.height
                    };
                }

                // Convert percentage-based fields to pixel coordinates
                state.placedFields = state.placedFields.map(f => {
                    const pageDims = state.pageDimensions[f.page] || {};
                    const canvasW = pageDims.canvasWidth || (612 * state.scale);
                    const canvasH = pageDims.canvasHeight || (792 * state.scale);

                    return {
                        ...f,
                        x: (f.xPercent / 100) * canvasW,
                        y: (f.yPercent / 100) * canvasH,
                        width: (f.widthPercent / 100) * canvasW,
                        height: (f.heightPercent / 100) * canvasH
                    };
                });

                // Find current recipient and set signing status
                const currentRecipient = result.session.recipients.find(r => r.id === recipientId);
                if (!currentRecipient) {
                    throw new Error('Recipient not found in this signing session');
                }

                // Update signing status
                const signerIndex = result.session.recipients
                    .filter(r => r.role === 'signer')
                    .findIndex(r => r.id === recipientId);

                state.signingStatus.currentSignerIndex = signerIndex >= 0 ? signerIndex : 0;
                state.signingStatus.completedSigners = result.session.recipients
                    .filter(r => r.signed)
                    .map(r => parseInt(r.id));

                showToast(`Ready to sign as ${currentRecipient.name}`);

                // CRITICAL: Initialize DocSign WASM module for remote signers
                // Without this, signatures cannot be applied to the PDF
                if (!state.docSign) {
                    console.log('[Signing] Initializing DocSign for remote signer...');
                    state.docSign = new DocSign();
                    const loadResult = state.docSign.load_pdf(state.pdfBytes);
                    if (!loadResult) {
                        throw new Error('Failed to load PDF into DocSign');
                    }
                    console.log('[Signing] DocSign initialized successfully');

                    // Cache page dimensions from DocSign
                    for (let i = 1; i <= state.totalPages; i++) {
                        const dims = state.docSign.page_dimensions(i);
                        if (dims && !state.pageDimensions[i]) {
                            state.pageDimensions[i] = {
                                width: dims.width,
                                height: dims.height,
                                canvasWidth: dims.width * state.scale,
                                canvasHeight: dims.height * state.scale
                            };
                        }
                    }
                }

                // Setup UI
                elements.loadingOverlay.classList.add('hidden');
                setupFieldPlacement();

                // Bug #14 fix: Unhide app container for remote signing sessions
                // The normal login flow unhides this at line ~2760, but remote signers
                // bypass that flow entirely
                const appContainer = document.getElementById('app-container');
                if (appContainer) {
                    appContainer.classList.remove('hidden');
                }
                // Also hide the landing page
                const landingPage = document.getElementById('landing-page');
                if (landingPage) {
                    landingPage.classList.add('hidden');
                }

                // Go directly to review/sign step
                goToStep(4);
            } catch (err) {
                console.error('Failed to load remote session:', err);
                elements.loadingOverlay.classList.add('hidden');
                showToast('Failed to load signing session: ' + (err.message || err));
            }
        }

        async function submitSignedDocument() {
            try {
                if (!state.remoteSession.sessionId) {
                    throw new Error('No active signing session');
                }

                // CRITICAL: Get the SIGNED PDF bytes from DocSign, not the original pdfBytes
                // The original state.pdfBytes is unchanged - the signed version is in the WASM module
                if (!state.docSign) {
                    throw new Error('DocSign not initialized - cannot retrieve signed document');
                }

                const signedPdfBytes = state.docSign.get_document_bytes();
                if (!signedPdfBytes || signedPdfBytes.length === 0) {
                    throw new Error('Failed to get signed document bytes');
                }

                console.log('[Signing] Submitting signed document, size:', signedPdfBytes.length);

                // Encode the signed PDF as base64 (no encryption - Bug #14 fix)
                // Use SOTA uint8ArrayToBase64 helper to avoid stack overflow on large PDFs
                const documentBase64 = uint8ArrayToBase64(new Uint8Array(signedPdfBytes));

                // Submit to server
                const response = await fetch(
                    `${SIGNING_SERVER_URL}/session/${state.remoteSession.sessionId}/signed`,
                    {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            recipient_id: state.remoteSession.recipientId,
                            encrypted_document: documentBase64  // Field name kept for API compatibility
                        })
                    }
                );

                const result = await response.json();
                if (!result.success) {
                    throw new Error(result.message || 'Failed to submit signed document');
                }

                showToast('Signed document submitted successfully!');
                return true;
            } catch (err) {
                console.error('Failed to submit signed document:', err);
                showToast('Failed to submit: ' + (err.message || err));
                return false;
            }
        }

        // Check for signing link on page load
        async function checkForSigningLink() {
            const hash = window.location.hash;
            const queryString = window.location.search;

            if (hash.startsWith('#sign=')) {
                // Parse the signing link
                // Format (no encryption - Bug #14 fix):
                //   1. #sign=SESSION_ID:RECIPIENT_ID (no token)
                //   2. #sign=SESSION_ID:RECIPIENT_ID?token=TOKEN (token in hash fragment)
                //   3. ?token=TOKEN#sign=SESSION_ID:RECIPIENT_ID (token in query string, preferred)
                // Legacy format with encryption key is also supported for backwards compatibility:
                //   #sign=SESSION_ID:RECIPIENT_ID:KEY

                let token = null;
                let signData = hash.slice(6); // Remove '#sign='

                // Check for token in query string first (preferred format)
                if (queryString) {
                    const queryParams = new URLSearchParams(queryString);
                    token = queryParams.get('token');
                }

                // Check for token embedded in hash fragment (server appends ?token= to end of hash)
                // Format: SESSION_ID:RECIPIENT_ID?token=TOKEN
                if (!token && signData.includes('?token=')) {
                    const [dataWithoutToken, tokenPart] = signData.split('?token=');
                    signData = dataWithoutToken;
                    token = tokenPart;
                }

                let sessionId, recipientId;
                const parts = signData.split(':');

                if (parts.length >= 2) {
                    // Colon-separated format: SESSION_ID:RECIPIENT_ID (or SESSION_ID:RECIPIENT_ID:KEY for legacy)
                    sessionId = parts[0];
                    recipientId = parts[1];
                    // parts[2] would be keyBase64 if present (legacy format), but we ignore it now
                } else {
                    // Fallback: Try query param format for backwards compatibility
                    // Format: #sign=SESSION_ID&r=RECIPIENT_ID
                    const params = new URLSearchParams(hash.slice(1));
                    sessionId = params.get('sign');
                    recipientId = params.get('r');
                }

                if (sessionId && recipientId) {
                    console.log('[Signing] Loading session:', sessionId, 'for recipient:', recipientId, 'token:', token ? 'present' : 'missing');

                    // Clear hash to prevent reload issues
                    history.replaceState(null, '', window.location.pathname);

                    // Show loading
                    elements.loadingOverlay.classList.remove('hidden');

                    // Load the remote session (pass token for authentication)
                    // No encryption key needed - documents are stored as plain base64
                    await loadRemoteSession(sessionId, recipientId, token);
                } else {
                    console.error('[Signing] Invalid signing link - missing params:', { sessionId: !!sessionId, recipientId: !!recipientId });
                    showToast('Invalid signing link. Please check the link and try again.');
                    elements.loadingOverlay.classList.add('hidden');
                }
            }
        }

        // Event Listeners
        elements.dropZone.addEventListener('click', () => elements.fileInput.click());
        elements.dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            elements.dropZone.classList.add('dragover');
        });
        elements.dropZone.addEventListener('dragleave', () => {
            elements.dropZone.classList.remove('dragover');
        });
        elements.dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            elements.dropZone.classList.remove('dragover');
            const file = e.dataTransfer.files[0];
            if (file?.type === 'application/pdf') {
                loadPDF(file);
            } else {
                showToast('Please drop a PDF file');
            }
        });
        elements.fileInput.addEventListener('change', (e) => {
            if (e.target.files[0]) loadPDF(e.target.files[0]);
        });

        elements.addRecipientBtn.addEventListener('click', addRecipient);
        elements.recipientEmail.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') addRecipient();
        });

        elements.prevPageBtn.addEventListener('click', () => {
            if (state.currentPage > 1) {
                state.currentPage--;
                scrollToPage(state.currentPage);
            }
        });
        elements.nextPageBtn.addEventListener('click', () => {
            if (state.currentPage < state.totalPages) {
                state.currentPage++;
                scrollToPage(state.currentPage);
            }
        });

        // Navigation buttons
        elements.btnBack.addEventListener('click', () => goToStep(state.currentStep - 1));
        elements.btnNext.addEventListener('click', () => goToStep(state.currentStep + 1));
        elements.btnSaveDraft.addEventListener('click', saveDraft);
        elements.btnSend.addEventListener('click', sendForSigning);
        elements.btnDownload.addEventListener('click', downloadPDF);
        elements.btnGenerateLinks.addEventListener('click', generateSigningLinks);
        elements.btnSettings.addEventListener('click', openSettings);
        elements.btnDarkMode.addEventListener('click', toggleDarkMode);

        // Template buttons
        document.getElementById('btn-save-template').addEventListener('click', saveTemplateAs);
        document.getElementById('btn-load-template').addEventListener('click', loadTemplateModal);

        // Stepper click navigation with keyboard support
        elements.steps.forEach(step => {
            const handleStepActivation = () => {
                const targetStep = parseInt(step.dataset.step);
                // Only allow going back or to completed steps
                if (targetStep < state.currentStep) {
                    goToStep(targetStep);
                }
            };
            step.addEventListener('click', handleStepActivation);
            step.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    handleStepActivation();
                }
            });
            step.style.cursor = 'pointer';
        });

        // Field type keyboard support
        elements.fieldTypes.forEach(fieldType => {
            fieldType.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    const type = fieldType.dataset.type;
                    setFieldType(type);
                }
            });
        });

        // Drop zone keyboard support
        elements.dropZone.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' || e.key === ' ') {
                e.preventDefault();
                elements.fileInput.click();
            }
        });

        // Initialize
        initialize();

        // Expose state for E2E testing
        window.state = state;
    </script>

    <!-- Footer with Legal Links (Bug #5) -->
    <footer style="text-align: center; padding: 1rem 1.5rem; color: #6b7280; font-size: 13px; border-top: 1px solid #e5e7eb; background: #f9fafb;">
        <a href="/legal.html" target="_blank" style="color: #6b7280; text-decoration: none; margin-right: 1rem;">Terms</a>
        <a href="/legal.html#privacy" target="_blank" style="color: #6b7280; text-decoration: none; margin-right: 1rem;">Privacy</a>
        <a href="/pricing.html" target="_blank" style="color: #6b7280; text-decoration: none;">Pricing</a>
    </footer>
</body>
</html>
